<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>响应系统的作用与实现 | v123ve</title>
    <meta name="description" content="思维垃圾">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/assets/style.COtxG_wp.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.CVivrEOL.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/theme.BgPG5jxD.js">
    <link rel="modulepreload" href="/assets/chunks/framework.BaR4VHXY.js">
    <link rel="modulepreload" href="/assets/zh-CN_工作笔记_响应系统的作用与实现.md.FBjfpL_B.lean.js">
    <link rel="icon" href="/favicon.ico">
    <meta name="keywords" content="思维垃圾">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0f60ec36></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0f60ec36> Skip to content </a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar" data-v-ae24b3ad data-v-6aa21345><div class="wrapper" data-v-6aa21345><div class="container" data-v-6aa21345><div class="title" data-v-6aa21345><div class="VPNavBarTitle" data-v-6aa21345 data-v-1168a8e4><a class="title" href="/" data-v-1168a8e4><!--[--><!--]--><!--[--><img class="VPImage logo" src="/v-logo.png" alt data-v-8426fc1a><!--]--><span data-v-1168a8e4>v123ve</span><!--[--><!--]--></a></div></div><div class="content" data-v-6aa21345><div class="content-body" data-v-6aa21345><!--[--><!--]--><div class="VPNavBarSearch search" data-v-6aa21345><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-6aa21345 data-v-dc692963><span id="main-nav-aria-label" class="visually-hidden" data-v-dc692963> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>主页</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-dc692963 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-cf11d7a2><span class="text" data-v-cf11d7a2><!----><span data-v-cf11d7a2>学习笔记</span><span class="vpi-chevron-down text-icon" data-v-cf11d7a2></span></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><div class="items" data-v-b98bc113><!--[--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(6).html" data-v-35975db6><!--[--><span data-v-35975db6>23种设计模式(6)</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/annatation%E6%B3%A8%E8%A7%A3.html" data-v-35975db6><!--[--><span data-v-35975db6>annatation注解</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Apache%20Shiro.html" data-v-35975db6><!--[--><span data-v-35975db6>Apache Shiro</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/BinaryInsertSort.java.html" data-v-35975db6><!--[--><span data-v-35975db6>BinaryInsertSort.java</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/IOC%20%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%88inversion%20of%20control%EF%BC%89.html" data-v-35975db6><!--[--><span data-v-35975db6>IOC 控制反转（inversion of control）</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java-web%E5%B7%A5%E7%A8%8B.html" data-v-35975db6><!--[--><span data-v-35975db6>java-web工程</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java%E7%9B%B8%E5%85%B3.html" data-v-35975db6><!--[--><span data-v-35975db6>java相关</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7.html" data-v-35975db6><!--[--><span data-v-35975db6>java高级特性</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/jdbc.html" data-v-35975db6><!--[--><span data-v-35975db6>jdbc</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux.html" data-v-35975db6><!--[--><span data-v-35975db6>linux</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/mybatis.html" data-v-35975db6><!--[--><span data-v-35975db6>mybatis</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/myxml.html" data-v-35975db6><!--[--><span data-v-35975db6>myxml</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/nginx%E7%AE%80%E4%BB%8B.html" data-v-35975db6><!--[--><span data-v-35975db6>nginx简介</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis.html" data-v-35975db6><!--[--><span data-v-35975db6>Redis</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/shell%E7%BC%96%E7%A8%8B.html" data-v-35975db6><!--[--><span data-v-35975db6>shell编程</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/socket%20tcp%20udp.html" data-v-35975db6><!--[--><span data-v-35975db6>socket tcp udp</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring%20Boot.html" data-v-35975db6><!--[--><span data-v-35975db6>Spring Boot</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/spring%20mvc%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91.html" data-v-35975db6><!--[--><span data-v-35975db6>spring mvc 多线程并发</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringBoot.html" data-v-35975db6><!--[--><span data-v-35975db6>SpringBoot</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/springmvc%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%9A.html" data-v-35975db6><!--[--><span data-v-35975db6>springmvc的配置：</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.html" data-v-35975db6><!--[--><span data-v-35975db6>spring定时任务</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/spring%E7%AE%80%E4%BB%8B.html" data-v-35975db6><!--[--><span data-v-35975db6>spring简介</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Swagger.html" data-v-35975db6><!--[--><span data-v-35975db6>Swagger</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/学习笔记/web.xml" data-v-35975db6><!--[--><span data-v-35975db6>web.xml</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Zookeeper.html" data-v-35975db6><!--[--><span data-v-35975db6>Zookeeper</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E6%9C%9F.html" data-v-35975db6><!--[--><span data-v-35975db6>二期</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html" data-v-35975db6><!--[--><span data-v-35975db6>代理模式</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8Heritrix%20%E7%88%AC%E5%8F%96%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90.html" data-v-35975db6><!--[--><span data-v-35975db6>使用Heritrix 爬取网络资源</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86.html" data-v-35975db6><!--[--><span data-v-35975db6>分布式微服务架构原理</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E6%A1%86%E6%9E%B6ES.html" data-v-35975db6><!--[--><span data-v-35975db6>分布式搜索框架ES</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka.html" data-v-35975db6><!--[--><span data-v-35975db6>分布式消息队列kafka</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%9B%E5%A4%A7%E9%87%91%E5%88%9A.html" data-v-35975db6><!--[--><span data-v-35975db6>四大金刚</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9C%A8JS%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E7%82%B9%E4%B9%8B%E5%90%8E%E7%9A%84%E5%90%8E%E7%BC%80%E5%AD%97%E7%AC%A6.html" data-v-35975db6><!--[--><span data-v-35975db6>在JS中获取文件点之后的后缀字符</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A7%E6%95%B0%E6%8D%AE.html" data-v-35975db6><!--[--><span data-v-35975db6>大数据</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F.html" data-v-35975db6><!--[--><span data-v-35975db6>排序</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%8E%B7%E5%8F%96%E8%A1%8C%E6%94%BF%E5%8C%BA%E8%8C%83%E5%9B%B4.html" data-v-35975db6><!--[--><span data-v-35975db6>获取行政区范围</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%8F%B1%E5%BD%A2.html" data-v-35975db6><!--[--><span data-v-35975db6>菱形</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A.html" data-v-35975db6><!--[--><span data-v-35975db6>进程和线程的区别：</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9B%B6XML%E9%85%8D%E7%BD%AEss.html" data-v-35975db6><!--[--><span data-v-35975db6>零XML配置ss</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9B%B6%E9%85%8D%E7%BD%AEssm%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88.html" data-v-35975db6><!--[--><span data-v-35975db6>零配置ssm框架整合</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C.html" data-v-35975db6><!--[--><span data-v-35975db6>面试经验</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup active" data-v-dc692963 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-cf11d7a2><span class="text" data-v-cf11d7a2><!----><span data-v-cf11d7a2>工作笔记</span><span class="vpi-chevron-down text-icon" data-v-cf11d7a2></span></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><div class="items" data-v-b98bc113><!--[--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/ad-grid%E6%8C%89%E6%97%A0%E3%80%81%E7%AC%A6%E5%8F%B7%E3%80%81%E6%95%B0%E5%AD%97%E3%80%81%E5%AD%97%E6%AF%8D%E3%80%81%E4%B8%AD%E6%96%87%E6%8E%92%E5%BA%8F.html" data-v-35975db6><!--[--><span data-v-35975db6>ad-grid按无、符号、数字、字母、中文排序</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/CodeMirror.html" data-v-35975db6><!--[--><span data-v-35975db6>CodeMirror</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/content%E5%9B%BE%E6%A0%87%E5%BA%93.html" data-v-35975db6><!--[--><span data-v-35975db6>content图标库</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/CSS%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html" data-v-35975db6><!--[--><span data-v-35975db6>CSS常用操作</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/CSS%E9%85%B7%E7%82%AB%E5%AE%9E%E7%8E%B0.html" data-v-35975db6><!--[--><span data-v-35975db6>CSS酷炫实现</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/Docker.html" data-v-35975db6><!--[--><span data-v-35975db6>Docker</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/dumi.html" data-v-35975db6><!--[--><span data-v-35975db6>dumi</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/easy-ui%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html" data-v-35975db6><!--[--><span data-v-35975db6>easy-ui常用操作</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/ES6%E5%A4%9A%E7%BB%A7%E6%89%BF.html" data-v-35975db6><!--[--><span data-v-35975db6>ES6多继承</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/idea%E8%AE%BE%E7%BD%AE%E6%95%99%E7%A8%8B.html" data-v-35975db6><!--[--><span data-v-35975db6>idea设置教程</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/iframe%E8%B7%A8%E5%9F%9F.html" data-v-35975db6><!--[--><span data-v-35975db6>iframe跨域</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/JavaUtils.html" data-v-35975db6><!--[--><span data-v-35975db6>JavaUtils</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/java%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html" data-v-35975db6><!--[--><span data-v-35975db6>java常用操作</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/js%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html" data-v-35975db6><!--[--><span data-v-35975db6>js常用操作</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/js%E7%94%9F%E6%88%90%E6%A0%91.html" data-v-35975db6><!--[--><span data-v-35975db6>js生成树</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/less.html" data-v-35975db6><!--[--><span data-v-35975db6>less</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/listary%E9%9B%86%E6%88%90everything.html" data-v-35975db6><!--[--><span data-v-35975db6>listary集成everything</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/lodash.html" data-v-35975db6><!--[--><span data-v-35975db6>lodash</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/mock%E7%A4%BA%E4%BE%8B.html" data-v-35975db6><!--[--><span data-v-35975db6>mock示例</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/nginx%E4%B8%8D%E7%BC%93%E5%AD%98%E8%AE%BE%E7%BD%AE.html" data-v-35975db6><!--[--><span data-v-35975db6>nginx不缓存设置</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/nginx%E6%AD%A3%E5%88%99%E5%8F%96%E5%8F%8D.html" data-v-35975db6><!--[--><span data-v-35975db6>nginx正则取反</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/NodeJs%E5%92%8CWebPack.html" data-v-35975db6><!--[--><span data-v-35975db6>NodeJs和WebPack</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/React%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html" data-v-35975db6><!--[--><span data-v-35975db6>React常用操作</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/React%E9%AB%98%E7%BA%A7.html" data-v-35975db6><!--[--><span data-v-35975db6>React高级</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/samba.html" data-v-35975db6><!--[--><span data-v-35975db6>samba</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/Sql%E7%9B%B8%E5%85%B3.html" data-v-35975db6><!--[--><span data-v-35975db6>Sql相关</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/umi2_pnpm.html" data-v-35975db6><!--[--><span data-v-35975db6>umi2_pnpm</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/VideoCommon.html" data-v-35975db6><!--[--><span data-v-35975db6>VideoCommon</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/VSCode.html" data-v-35975db6><!--[--><span data-v-35975db6>VSCode</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/Webpack%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86.html" data-v-35975db6><!--[--><span data-v-35975db6>Webpack代码混淆</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/WebSocket.html" data-v-35975db6><!--[--><span data-v-35975db6>WebSocket</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/windows%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html" data-v-35975db6><!--[--><span data-v-35975db6>windows常用操作</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/%E5%88%9B%E5%BB%BAoffer.html" data-v-35975db6><!--[--><span data-v-35975db6>创建offer</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2.html" data-v-35975db6><!--[--><span data-v-35975db6>前端开发环境部署</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86.html" data-v-35975db6><!--[--><span data-v-35975db6>加密解密</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/%E5%8F%89%E5%8F%B7.html" data-v-35975db6><!--[--><span data-v-35975db6>叉号</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/%E5%8F%8C%E5%87%BB%E5%A4%84%E7%90%86.html" data-v-35975db6><!--[--><span data-v-35975db6>双击处理</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/%E5%90%91%E9%87%8F%E5%8F%89%E4%B9%98.html" data-v-35975db6><!--[--><span data-v-35975db6>向量叉乘</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link active" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html" data-v-35975db6><!--[--><span data-v-35975db6>响应系统的作用与实现</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/%E5%A5%87%E5%81%B6%E5%B2%B8%E8%BE%B9.html" data-v-35975db6><!--[--><span data-v-35975db6>奇偶岸边</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85.html" data-v-35975db6><!--[--><span data-v-35975db6>安装</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%A0%91.html" data-v-35975db6><!--[--><span data-v-35975db6>排序和树</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD.html" data-v-35975db6><!--[--><span data-v-35975db6>文件下载</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/%E6%B8%B2%E6%9F%93%E5%99%A8%E5%92%8CDiff%E7%AE%97%E6%B3%95.html" data-v-35975db6><!--[--><span data-v-35975db6>渲染器和Diff算法</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/zh-CN/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/%E7%94%9F%E6%88%90%E9%A5%BC%E7%8A%B6%E5%9B%BE.html" data-v-35975db6><!--[--><span data-v-35975db6>生成饼状图</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-dc692963 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-cf11d7a2><span class="text" data-v-cf11d7a2><!----><span data-v-cf11d7a2>记录笔记</span><span class="vpi-chevron-down text-icon" data-v-cf11d7a2></span></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><div class="items" data-v-b98bc113><!--[--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><div class="VPFlyout VPNavBarTranslations translations" data-v-6aa21345 data-v-88af2de4 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="Change language" data-v-cf11d7a2><span class="text" data-v-cf11d7a2><span class="vpi-languages option-icon" data-v-cf11d7a2></span><!----><span class="vpi-chevron-down text-icon" data-v-cf11d7a2></span></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><!----><!--[--><!--[--><div class="items" data-v-88af2de4><p class="title" data-v-88af2de4>简体中文</p><!--[--><div class="VPMenuLink" data-v-88af2de4 data-v-35975db6><a class="VPLink link active" href="/zh-CN/工作笔记/响应系统的作用与实现.html" data-v-35975db6><!--[--><span data-v-35975db6>English</span><!--]--></a></div><!--]--></div><!--]--><!--]--></div></div></div><div class="VPNavBarAppearance appearance" data-v-6aa21345 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-6aa21345 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-6aa21345 data-v-bb2aa2f0 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-cf11d7a2><span class="vpi-more-horizontal icon" data-v-cf11d7a2></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><!----><!--[--><!--[--><div class="group translations" data-v-bb2aa2f0><p class="trans-title" data-v-bb2aa2f0>简体中文</p><!--[--><div class="VPMenuLink" data-v-bb2aa2f0 data-v-35975db6><a class="VPLink link active" href="/zh-CN/工作笔记/响应系统的作用与实现.html" data-v-35975db6><!--[--><span data-v-35975db6>English</span><!--]--></a></div><!--]--></div><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>主题</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bb2aa2f0><div class="item social-links" data-v-bb2aa2f0><div class="VPSocialLinks social-links-list" data-v-bb2aa2f0 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-6aa21345 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-6aa21345><div class="divider-line" data-v-6aa21345></div></div></div><!----></header><div class="VPLocalNav empty fixed" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><!----><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-17a5e62e><button data-v-17a5e62e>返回顶部</button><!----></div></div></div><!----><div class="VPContent" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-a5bbad30><div class="content" data-v-a5bbad30><div class="outline-marker" data-v-a5bbad30></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-a5bbad30>目录</div><ul class="VPDocOutlineItem root" data-v-a5bbad30 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _zh-CN_%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0_%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0" data-v-39a288b8><div><h1 id="响应系统的作用与实现" tabindex="-1">响应系统的作用与实现 <a class="header-anchor" href="#响应系统的作用与实现" aria-label="Permalink to &quot;响应系统的作用与实现&quot;">​</a></h1><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 存储副作用的桶</span></span>
<span class="line"><span>    const bucket = new WeakMap();</span></span>
<span class="line"><span>    // 用一个全局变量存储被注册的副作用函数</span></span>
<span class="line"><span>    let activeEffect;</span></span>
<span class="line"><span>    // effect 栈</span></span>
<span class="line"><span>    const effectStack = [];</span></span>
<span class="line"><span>    // 迭代器关键字</span></span>
<span class="line"><span>    const ITERATE_KEY = Symbol()</span></span>
<span class="line"><span>    // MAP类型迭代器关键字</span></span>
<span class="line"><span>    const MAP_KEY_ITERATE_KEY = Symbol()</span></span>
<span class="line"><span>    // 操作类型枚举值</span></span>
<span class="line"><span>    const TriggerType = {</span></span>
<span class="line"><span>        SET: &#39;SET&#39;,</span></span>
<span class="line"><span>        ADD: &#39;ADD&#39;,</span></span>
<span class="line"><span>        DELETE: &#39;DELETE&#39;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // 一个标记变量，代表是否进行追踪。默认值为 true , 即允许追踪</span></span>
<span class="line"><span>    let shouldTrack = true;</span></span>
<span class="line"><span>    // 定义一个 Map 实例，存储原始对象到代理对象的映射</span></span>
<span class="line"><span>    const reactiveMap = new Map();</span></span>
<span class="line"><span>    // 对非原始值的响应式方案</span></span>
<span class="line"><span>    // 从原型上继承属性,屏蔽原型引起的更新</span></span>
<span class="line"><span>    // isShallow 代表是否是浅响应</span></span>
<span class="line"><span>    // isReadOnly 代表是否只读</span></span>
<span class="line"><span>    function reactive(obj, isShallow = false, isReadOnly = false) {</span></span>
<span class="line"><span>        // 优先通过原始对象 obj 寻找之前创建的代理对象</span></span>
<span class="line"><span>        const existionProxy = reactiveMap.get(obj)</span></span>
<span class="line"><span>        if (existionProxy) return existionProxy</span></span>
<span class="line"><span>        // 否则，创建新的代理对象</span></span>
<span class="line"><span>        const proxy = new Proxy(obj, {</span></span>
<span class="line"><span>            // 拦截读取操作</span></span>
<span class="line"><span>            get(target, key, receiver) {</span></span>
<span class="line"><span>                // 代理对象可以通过 raw 属性访问原始数据</span></span>
<span class="line"><span>                if (key === &#39;raw&#39;) return target</span></span>
<span class="line"><span>                // 如果操作的目标对象是数组</span></span>
<span class="line"><span>                if (Array.isArray(target)) {</span></span>
<span class="line"><span>                    // 重写数组方法实现自定义行为,找出代理对象和原始对象的共有值</span></span>
<span class="line"><span>                    const arrayInstrumentations = {};</span></span>
<span class="line"><span>                    // 例:obj={};arr=reactive([obj]);console.log(arr.includes(arr[0]),arr.includes(obj))应均为 true</span></span>
<span class="line"><span>                    [&#39;includes&#39;, &#39;indexOf&#39;, &#39;lastIndexOf&#39;].forEach(method =&gt; {</span></span>
<span class="line"><span>                        const originMethod = Array.prototype[method]</span></span>
<span class="line"><span>                        arrayInstrumentations[method] = function (...args) {</span></span>
<span class="line"><span>                            // this 是代理对象，先在代理对象中查找，将结果存储到 res 中</span></span>
<span class="line"><span>                            let res = originMethod.apply(this, args)</span></span>
<span class="line"><span>                            if (res === false || res === -1) {</span></span>
<span class="line"><span>                                // res 为 false 说明没找到，通过 this.raw 拿到原始数值，再去其中查找并更新 res 值</span></span>
<span class="line"><span>                                res = originMethod.apply(this.raw, args)</span></span>
<span class="line"><span>                            }</span></span>
<span class="line"><span>                            // 返回最终结果</span></span>
<span class="line"><span>                            return res</span></span>
<span class="line"><span>                        }</span></span>
<span class="line"><span>                    });</span></span>
<span class="line"><span>                    [&#39;push&#39;, &#39;pop&#39;, &#39;shift&#39;, &#39;unshift&#39;, &#39;splice&#39;].forEach(method =&gt; {</span></span>
<span class="line"><span>                        const originMethod = Array.prototype[method]</span></span>
<span class="line"><span>                        arrayInstrumentations[method] = function (...args) {</span></span>
<span class="line"><span>                            // 在调用原始方法之前，禁止追踪</span></span>
<span class="line"><span>                            shouldTrack = false</span></span>
<span class="line"><span>                            // 原始方法的默认行为</span></span>
<span class="line"><span>                            let res = originMethod.apply(this, args)</span></span>
<span class="line"><span>                            // 在调用原始方法之后，恢复原来的行为，即允许追踪</span></span>
<span class="line"><span>                            shouldTrack = true</span></span>
<span class="line"><span>                            // 返回最终结果</span></span>
<span class="line"><span>                            return res</span></span>
<span class="line"><span>                        }</span></span>
<span class="line"><span>                    });</span></span>
<span class="line"><span>                    // key 存在于 arrayInstrumentations 上,那么返回定义在 arrayInstrumentations 上的值</span></span>
<span class="line"><span>                    if (arrayInstrumentations.hasOwnProperty(key)) {</span></span>
<span class="line"><span>                        return Reflect.get(arrayInstrumentations, key, receiver)</span></span>
<span class="line"><span>                    }</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>                // 如果操作的目标对象是Set、Map</span></span>
<span class="line"><span>                if (target instanceof Set || target instanceof Map) {</span></span>
<span class="line"><span>                    // 重写Set、Map方法实现自定义行为</span></span>
<span class="line"><span>                    const mutableInstrumentations = {</span></span>
<span class="line"><span>                        get(key) {</span></span>
<span class="line"><span>                            // this 仍然指向的是代理对象，通过 raw 属性获取原始数据对象</span></span>
<span class="line"><span>                            const target = this.raw</span></span>
<span class="line"><span>                            // 先判断值是否已存在</span></span>
<span class="line"><span>                            const hadKey = target.has(key)</span></span>
<span class="line"><span>                            // 追踪依赖，建立联系</span></span>
<span class="line"><span>                            track(target, key);</span></span>
<span class="line"><span>                            // 只有在值存在的情况下，才需要触发响应</span></span>
<span class="line"><span>                            if (hadKey) {</span></span>
<span class="line"><span>                                const res = target.get(key)</span></span>
<span class="line"><span>                                // 如果是浅响应,直接返回原始值</span></span>
<span class="line"><span>                                if (isShallow) return res</span></span>
<span class="line"><span>                                // 如果得到的结果仍是可代理的数据，调用 reactive 将结果包装成响应式数据并返回</span></span>
<span class="line"><span>                                return typeof res === &#39;object&#39; ? reactive(res) : res</span></span>
<span class="line"><span>                            }</span></span>
<span class="line"><span>                        },</span></span>
<span class="line"><span>                        set(key, value) {</span></span>
<span class="line"><span>                            // this 仍然指向的是代理对象，通过 raw 属性获取原始数据对象</span></span>
<span class="line"><span>                            const target = this.raw</span></span>
<span class="line"><span>                            // 先判断值是否已存在</span></span>
<span class="line"><span>                            const hadKey = target.has(key)</span></span>
<span class="line"><span>                            // 获取旧值</span></span>
<span class="line"><span>                            const oldVal = target.get(key)</span></span>
<span class="line"><span>                            // 设置新值,获取原始数据，避免新值是响应式数据</span></span>
<span class="line"><span>                            const rawValue = value.raw || value</span></span>
<span class="line"><span>                            target.set(key, rawValue)</span></span>
<span class="line"><span>                            // 值不存在说明是 ADD 类型的操作，意味着新增</span></span>
<span class="line"><span>                            if (!hadKey) {</span></span>
<span class="line"><span>                                trigger(target, key, TriggerType.ADD)</span></span>
<span class="line"><span>                            } else if (oldVal !== newVal &amp;&amp; (oldVal === oldVal || newVal === newVal)) {</span></span>
<span class="line"><span>                                // 值存在说明是 SET 类型的操作，意味着修改</span></span>
<span class="line"><span>                                trigger(target, key, TriggerType.SET)</span></span>
<span class="line"><span>                            }</span></span>
<span class="line"><span>                        },</span></span>
<span class="line"><span>                        add(key) {</span></span>
<span class="line"><span>                            // this 仍然指向的是代理对象，通过 raw 属性获取原始数据对象</span></span>
<span class="line"><span>                            const target = this.raw</span></span>
<span class="line"><span>                            // 先判断值是否已存在</span></span>
<span class="line"><span>                            const hadKey = target.has(key)</span></span>
<span class="line"><span>                            // 只有在值不存在的情况下，才需要触发响应</span></span>
<span class="line"><span>                            // 设置新值,获取原始数据，避免新值是响应式数据</span></span>
<span class="line"><span>                            const rawValue = key.raw || key</span></span>
<span class="line"><span>                            const res = target.add(rawValue)</span></span>
<span class="line"><span>                            if (!hadKey) {</span></span>
<span class="line"><span>                                trigger(target, key, TriggerType.ADD)</span></span>
<span class="line"><span>                            }</span></span>
<span class="line"><span>                            return res</span></span>
<span class="line"><span>                        },</span></span>
<span class="line"><span>                        delete(key) {</span></span>
<span class="line"><span>                            // this 仍然指向的是代理对象，通过 raw 属性获取原始数据对象</span></span>
<span class="line"><span>                            const target = this.raw</span></span>
<span class="line"><span>                            // 先判断值是否已存在</span></span>
<span class="line"><span>                            const hadKey = target.has(key)</span></span>
<span class="line"><span>                            // 只有在值存在的情况下，才需要触发响应</span></span>
<span class="line"><span>                            const res = target.delete(key)</span></span>
<span class="line"><span>                            if (hadKey) {</span></span>
<span class="line"><span>                                trigger(target, key, TriggerType.DELETE)</span></span>
<span class="line"><span>                            }</span></span>
<span class="line"><span>                            return res</span></span>
<span class="line"><span>                        },</span></span>
<span class="line"><span>                        forEach(callback, thisArg) {</span></span>
<span class="line"><span>                            // this 仍然指向的是代理对象，通过 raw 属性获取原始数据对象</span></span>
<span class="line"><span>                            const target = this.raw</span></span>
<span class="line"><span>                            // 与 ITERATE_KEY 建立联系</span></span>
<span class="line"><span>                            track(target, ITERATE_KEY)</span></span>
<span class="line"><span>                            // wrap 函数用来把可代理的值转换为响应式数据</span></span>
<span class="line"><span>                            const wrap = (val) =&gt; typeof val === &#39;object&#39; ? reactive(val) : val</span></span>
<span class="line"><span>                            // 调用方法并传递</span></span>
<span class="line"><span>                            target.forEach((v, k) =&gt; {</span></span>
<span class="line"><span>                                // 通过 .call 调用并传递 thisArg ，用 wrap 函数包裹 value 和 key 后再传给 callback 实现深响应</span></span>
<span class="line"><span>                                callback.call(thisArg, wrap(v), wrap(k), this)</span></span>
<span class="line"><span>                            })</span></span>
<span class="line"><span>                        },</span></span>
<span class="line"><span>                        [Symbol.iterator]() {</span></span>
<span class="line"><span>                            // this 仍然指向的是代理对象，通过 raw 属性获取原始数据对象</span></span>
<span class="line"><span>                            const target = this.raw</span></span>
<span class="line"><span>                            // 获取原始迭代器方法</span></span>
<span class="line"><span>                            const itr = target[Symbol.iterator]()</span></span>
<span class="line"><span>                            // 与 ITERATE_KEY 建立联系</span></span>
<span class="line"><span>                            track(target, ITERATE_KEY)</span></span>
<span class="line"><span>                            // wrap 函数用来把可代理的值转换为响应式数据</span></span>
<span class="line"><span>                            const wrap = (val) =&gt; typeof val === &#39;object&#39; ? reactive(val) : val</span></span>
<span class="line"><span>                            // 返回自定义迭代器</span></span>
<span class="line"><span>                            return {</span></span>
<span class="line"><span>                                next() {</span></span>
<span class="line"><span>                                    // 调用原始迭代器的 next 方法获取 value 和 done</span></span>
<span class="line"><span>                                    const {</span></span>
<span class="line"><span>                                        value,</span></span>
<span class="line"><span>                                        done</span></span>
<span class="line"><span>                                    } = itr.next()</span></span>
<span class="line"><span>                                    // 如果 value 不是 undefine ，则对其包裹</span></span>
<span class="line"><span>                                    return {</span></span>
<span class="line"><span>                                        value: value ? [wrap(value[0]), wrap(value[1])] : value,</span></span>
<span class="line"><span>                                        done</span></span>
<span class="line"><span>                                    }</span></span>
<span class="line"><span>                                },</span></span>
<span class="line"><span>                                // 实现可迭代协议</span></span>
<span class="line"><span>                                [Symbol.iterator]() {</span></span>
<span class="line"><span>                                    return this</span></span>
<span class="line"><span>                                }</span></span>
<span class="line"><span>                            }</span></span>
<span class="line"><span>                        },</span></span>
<span class="line"><span>                        entries() {</span></span>
<span class="line"><span>                            // 等价于 [Symbol.iterator]</span></span>
<span class="line"><span>                            // this 仍然指向的是代理对象，通过 raw 属性获取原始数据对象</span></span>
<span class="line"><span>                            const target = this.raw</span></span>
<span class="line"><span>                            // 获取原始迭代器方法</span></span>
<span class="line"><span>                            const itr = target[Symbol.iterator]()</span></span>
<span class="line"><span>                            // 与 ITERATE_KEY 建立联系</span></span>
<span class="line"><span>                            track(target, ITERATE_KEY)</span></span>
<span class="line"><span>                            // wrap 函数用来把可代理的值转换为响应式数据</span></span>
<span class="line"><span>                            const wrap = (val) =&gt; typeof val === &#39;object&#39; ? reactive(val) : val</span></span>
<span class="line"><span>                            // 返回自定义迭代器</span></span>
<span class="line"><span>                            return {</span></span>
<span class="line"><span>                                next() {</span></span>
<span class="line"><span>                                    // 调用原始迭代器的 next 方法获取 value 和 done</span></span>
<span class="line"><span>                                    const {</span></span>
<span class="line"><span>                                        value,</span></span>
<span class="line"><span>                                        done</span></span>
<span class="line"><span>                                    } = itr.next()</span></span>
<span class="line"><span>                                    // 如果 value 不是 undefine ，则对其包裹</span></span>
<span class="line"><span>                                    return {</span></span>
<span class="line"><span>                                        value: value ? [wrap(value[0]), wrap(value[1])] : value,</span></span>
<span class="line"><span>                                        done</span></span>
<span class="line"><span>                                    }</span></span>
<span class="line"><span>                                },</span></span>
<span class="line"><span>                                // 实现可迭代协议</span></span>
<span class="line"><span>                                [Symbol.iterator]() {</span></span>
<span class="line"><span>                                    return this</span></span>
<span class="line"><span>                                }</span></span>
<span class="line"><span>                            }</span></span>
<span class="line"><span>                        },</span></span>
<span class="line"><span>                        values() {</span></span>
<span class="line"><span>                            // this 仍然指向的是代理对象，通过 raw 属性获取原始数据对象</span></span>
<span class="line"><span>                            const target = this.raw</span></span>
<span class="line"><span>                            // 获取原始迭代器方法</span></span>
<span class="line"><span>                            const itr = target.values()</span></span>
<span class="line"><span>                            // 与 ITERATE_KEY 建立联系</span></span>
<span class="line"><span>                            track(target, ITERATE_KEY)</span></span>
<span class="line"><span>                            // wrap 函数用来把可代理的值转换为响应式数据</span></span>
<span class="line"><span>                            const wrap = (val) =&gt; typeof val === &#39;object&#39; ? reactive(val) : val</span></span>
<span class="line"><span>                            // 返回自定义迭代器</span></span>
<span class="line"><span>                            return {</span></span>
<span class="line"><span>                                next() {</span></span>
<span class="line"><span>                                    // 调用原始迭代器的 next 方法获取 value 和 done</span></span>
<span class="line"><span>                                    const {</span></span>
<span class="line"><span>                                        value,</span></span>
<span class="line"><span>                                        done</span></span>
<span class="line"><span>                                    } = itr.next()</span></span>
<span class="line"><span>                                    // 如果 value 不是 undefine ，则对其包裹</span></span>
<span class="line"><span>                                    // value 是值，而非键值对，所以只需要包裹 value 即可</span></span>
<span class="line"><span>                                    return {</span></span>
<span class="line"><span>                                        value: value ? [wrap(value)] : value,</span></span>
<span class="line"><span>                                        done</span></span>
<span class="line"><span>                                    }</span></span>
<span class="line"><span>                                },</span></span>
<span class="line"><span>                                // 实现可迭代协议</span></span>
<span class="line"><span>                                [Symbol.iterator]() {</span></span>
<span class="line"><span>                                    return this</span></span>
<span class="line"><span>                                }</span></span>
<span class="line"><span>                            }</span></span>
<span class="line"><span>                        },</span></span>
<span class="line"><span>                        keys() {</span></span>
<span class="line"><span>                            // this 仍然指向的是代理对象，通过 raw 属性获取原始数据对象</span></span>
<span class="line"><span>                            const target = this.raw</span></span>
<span class="line"><span>                            // 获取原始迭代器方法</span></span>
<span class="line"><span>                            const itr = target.keys()</span></span>
<span class="line"><span>                            // 与 MAP_KEY_ITERATE_KEY 建立联系</span></span>
<span class="line"><span>                            track(target, MAP_KEY_ITERATE_KEY)</span></span>
<span class="line"><span>                            // wrap 函数用来把可代理的值转换为响应式数据</span></span>
<span class="line"><span>                            const wrap = (val) =&gt; typeof val === &#39;object&#39; ? reactive(val) : val</span></span>
<span class="line"><span>                            // 返回自定义迭代器</span></span>
<span class="line"><span>                            return {</span></span>
<span class="line"><span>                                next() {</span></span>
<span class="line"><span>                                    // 调用原始迭代器的 next 方法获取 value 和 done</span></span>
<span class="line"><span>                                    const {</span></span>
<span class="line"><span>                                        value,</span></span>
<span class="line"><span>                                        done</span></span>
<span class="line"><span>                                    } = itr.next()</span></span>
<span class="line"><span>                                    // 如果 value 不是 undefine ，则对其包裹</span></span>
<span class="line"><span>                                    // value 是值，而非键值对，所以只需要包裹 value 即可</span></span>
<span class="line"><span>                                    return {</span></span>
<span class="line"><span>                                        value: value ? [wrap(value)] : value,</span></span>
<span class="line"><span>                                        done</span></span>
<span class="line"><span>                                    }</span></span>
<span class="line"><span>                                },</span></span>
<span class="line"><span>                                // 实现可迭代协议</span></span>
<span class="line"><span>                                [Symbol.iterator]() {</span></span>
<span class="line"><span>                                    return this</span></span>
<span class="line"><span>                                }</span></span>
<span class="line"><span>                            }</span></span>
<span class="line"><span>                        },</span></span>
<span class="line"><span>                    }</span></span>
<span class="line"><span>                    // 如果读取的是 size 属性，它是一个访问器方法</span></span>
<span class="line"><span>                    // 指定第三个参数 receiver 为原始对象 target 从而 set.size 可以建立联系</span></span>
<span class="line"><span>                    if (key === &#39;size&#39;) {</span></span>
<span class="line"><span>                        // 调用 track 函数建立响应联系</span></span>
<span class="line"><span>                        track(target, ITERATE_KEY);</span></span>
<span class="line"><span>                        return Reflect.get(target, key, target)</span></span>
<span class="line"><span>                    }</span></span>
<span class="line"><span>                    // 返回自定义方法</span></span>
<span class="line"><span>                    return mutableInstrumentations[key]</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>                // 非只读的时候或 key 非 symbol 类型时才建立响应联系</span></span>
<span class="line"><span>                if (!isReadOnly &amp;&amp; typeof key !== &#39;symbol&#39;) track(target, key);</span></span>
<span class="line"><span>                // 得到原始值结果</span></span>
<span class="line"><span>                const res = Reflect.get(target, key, receiver)</span></span>
<span class="line"><span>                // 如果是浅响应,直接返回原始值</span></span>
<span class="line"><span>                if (isShallow) return res</span></span>
<span class="line"><span>                // 调用 reactive 将结果包装成响应式数据并返回</span></span>
<span class="line"><span>                // 如果是只读的，为做到深只读，遍历值</span></span>
<span class="line"><span>                if (typeof res === &#39;object&#39; &amp;&amp; res !== null)</span></span>
<span class="line"><span>                    return isReadOnly ? reactive(res, isShallow, isReadOnly) : reactive(res)</span></span>
<span class="line"><span>                return res</span></span>
<span class="line"><span>            },</span></span>
<span class="line"><span>            // 拦截设置操作</span></span>
<span class="line"><span>            // target 原始对象</span></span>
<span class="line"><span>            // receiver 代理对象</span></span>
<span class="line"><span>            set(target, key, newVal, receiver) {</span></span>
<span class="line"><span>                if (isReadOnly) {</span></span>
<span class="line"><span>                    console.warn(`属性 ${key} 是只读的`);</span></span>
<span class="line"><span>                    return true</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>                // 获取旧值</span></span>
<span class="line"><span>                const oldVal = target[key]</span></span>
<span class="line"><span>                // 如果属性不存在，则说明是在添加新属性，否则是设置已有属性</span></span>
<span class="line"><span>                // 如果是数组则判断被设置的索引值是否小于数组长度</span></span>
<span class="line"><span>                const type = Array.isArray(target) ? Number(key) &lt; target.length ? TriggerType.SET : TriggerType.ADD : Object.prototype.hasOwnProperty.call(target, key) ? TriggerType.SET : TriggerType.ADD</span></span>
<span class="line"><span>                // 设置新值,获取原始数据，避免新值是响应式数据</span></span>
<span class="line"><span>                const rawValue = key.raw || key</span></span>
<span class="line"><span>                const res = Reflect.set(target, rawValue, newVal, receiver)</span></span>
<span class="line"><span>                // 如果 receiver 是 target 的代理对象</span></span>
<span class="line"><span>                if (target === receiver.raw) {</span></span>
<span class="line"><span>                    // 如果旧值不全等新值并且不是NaN，才触发响应</span></span>
<span class="line"><span>                    if (oldVal !== newVal &amp;&amp; (oldVal === oldVal || newVal === newVal)) trigger(target, key, type, newVal)</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>                return res</span></span>
<span class="line"><span>            },</span></span>
<span class="line"><span>            // 拦截 in 读取</span></span>
<span class="line"><span>            has(target, key) {</span></span>
<span class="line"><span>                track(target, key);</span></span>
<span class="line"><span>                return Reflect.has(target, key);</span></span>
<span class="line"><span>            },</span></span>
<span class="line"><span>            // 拦截 for...in 读取</span></span>
<span class="line"><span>            ownKeys(target) {</span></span>
<span class="line"><span>                // 如果目标是数组则使用 length 作为 key 建立响应联系</span></span>
<span class="line"><span>                track(target, Array.isArray(target) ? &#39;length&#39; : ITERATE_KEY);</span></span>
<span class="line"><span>                return Reflect.ownKeys(target);</span></span>
<span class="line"><span>            },</span></span>
<span class="line"><span>            // 拦截 delete 操作</span></span>
<span class="line"><span>            deleteProperty(target, key) {</span></span>
<span class="line"><span>                if (isReadOnly) {</span></span>
<span class="line"><span>                    console.warn(`属性 ${key} 是只读的`);</span></span>
<span class="line"><span>                    return true</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>                // 检查属性是否是对象自己的属性</span></span>
<span class="line"><span>                const hadKey = Object.prototype.hasOwnProperty.call(target, key)</span></span>
<span class="line"><span>                const res = Reflect.deleteProperty(target, key)</span></span>
<span class="line"><span>                // 如果成功删除并且是自己的属性时，触发更新</span></span>
<span class="line"><span>                if (res &amp;&amp; hadKey) {</span></span>
<span class="line"><span>                    trigger(target, key, TriggerType.DELETE)</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>                return res</span></span>
<span class="line"><span>            },</span></span>
<span class="line"><span>        });</span></span>
<span class="line"><span>        // 存储到 Map 中，从而避免重复创建</span></span>
<span class="line"><span>        reactiveMap.set(obj, proxy);</span></span>
<span class="line"><span>        return proxy</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // effect 函数用于注册副作用函数</span></span>
<span class="line"><span>    function effect(fn, options = {}) {</span></span>
<span class="line"><span>        // 清除之前的依赖关系</span></span>
<span class="line"><span>        function cleanup(effectFn) {</span></span>
<span class="line"><span>            for (let i = 0; i &lt; effectFn.effects.length; i++) {</span></span>
<span class="line"><span>                // 将 effectFn 从桶中对应的依赖集合中删除</span></span>
<span class="line"><span>                const bucketTargetKeyEffects = effectFn.effects[i];</span></span>
<span class="line"><span>                bucketTargetKeyEffects.delete(effectFn);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            // 重置 effectFn.effects</span></span>
<span class="line"><span>            effectFn.effects.length = 0;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        const effectFn = () =&gt; {</span></span>
<span class="line"><span>            // 清除</span></span>
<span class="line"><span>            cleanup(effectFn);</span></span>
<span class="line"><span>            // 当调用 effect 注册函数时,将副作用函数 fn 赋值给 activeEffect</span></span>
<span class="line"><span>            activeEffect = effectFn;</span></span>
<span class="line"><span>            // 在调用副作用函数前将当前函数压入栈中</span></span>
<span class="line"><span>            effectStack.push(effectFn);</span></span>
<span class="line"><span>            // 执行副作用函数,将执行结果保存</span></span>
<span class="line"><span>            const res = fn();</span></span>
<span class="line"><span>            // 在调用副作用函数后，将当前副作用函数弹出栈，并还原 activeEffect</span></span>
<span class="line"><span>            effectStack.pop();</span></span>
<span class="line"><span>            activeEffect = effectStack[effectStack.length - 1]</span></span>
<span class="line"><span>            // 返回执行结果</span></span>
<span class="line"><span>            return res</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        // 将 options 挂载到 effectFn 上</span></span>
<span class="line"><span>        effectFn.options = options</span></span>
<span class="line"><span>        // activeEffect.effects 用于存储所有与该副作用函数相关联的依赖集合,此行可省略？？？</span></span>
<span class="line"><span>        effectFn.effects = []</span></span>
<span class="line"><span>        // 非懒执行的副作用会立即执行</span></span>
<span class="line"><span>        if (!options.lazy) {</span></span>
<span class="line"><span>            effectFn();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        // 将副作用函数返回</span></span>
<span class="line"><span>        return effectFn</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // 追踪:将副作用函数提取</span></span>
<span class="line"><span>    function track(target, key) {</span></span>
<span class="line"><span>        // 没有 activeEffect 或禁止追踪时，直接 return</span></span>
<span class="line"><span>        if (!activeEffect || !shouldTrack) return</span></span>
<span class="line"><span>        // 根据 target 从“桶”中取得 depsMap , 它也是一个 Map 类型: key --&gt; effects</span></span>
<span class="line"><span>        let depsMap = bucket.get(target);</span></span>
<span class="line"><span>        // 如果不存在,新建</span></span>
<span class="line"><span>        if (!depsMap) {</span></span>
<span class="line"><span>            bucket.set(target, (depsMap = new Map()))</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        // 根据 key 从 depsMap 中取得 bucketTargetKeyEffects , 它是一个 Set 类型</span></span>
<span class="line"><span>        let bucketTargetKeyEffects = depsMap.get(key);</span></span>
<span class="line"><span>        // 如果不存在,新建</span></span>
<span class="line"><span>        if (!bucketTargetKeyEffects) {</span></span>
<span class="line"><span>            depsMap.set(key, (bucketTargetKeyEffects = new Set()))</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        // 将当前的副作用函数添加到“桶”</span></span>
<span class="line"><span>        bucketTargetKeyEffects.add(activeEffect);</span></span>
<span class="line"><span>        // effects 就是一个与该副作用函数相关联的依赖集合,将其添加到 activeEffect.effects 数组中</span></span>
<span class="line"><span>        activeEffect.effects.push(bucketTargetKeyEffects);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // 触发:把副作用函数从桶里取出并执行</span></span>
<span class="line"><span>    function trigger(target, key, type, newVal) {</span></span>
<span class="line"><span>        const depsMap = bucket.get(target);</span></span>
<span class="line"><span>        if (!depsMap) return</span></span>
<span class="line"><span>        const effects = depsMap.get(key);</span></span>
<span class="line"><span>        const effectsToRun = new Set();</span></span>
<span class="line"><span>        effects &amp;&amp; effects.forEach(effectFn =&gt; {</span></span>
<span class="line"><span>            // 如果 trigger 触发执行的副函数与当前正在执行的副函数相同</span></span>
<span class="line"><span>            // 说明在副作用函数中同时进行了读取和设置,导致无限循环,栈溢出</span></span>
<span class="line"><span>            // 不触发相同的副作用函数</span></span>
<span class="line"><span>            if (effectFn !== activeEffect) {</span></span>
<span class="line"><span>                effectsToRun.add(effectFn);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        });</span></span>
<span class="line"><span>        // 只有属性发送新增或删除时，才触发 ITERATE_KEY 相关联的副作用函数重新执行</span></span>
<span class="line"><span>        // 如果操作类型是 SET ，并且目标对象是 Map 时，也触发</span></span>
<span class="line"><span>        if (type === TriggerType.ADD || type === TriggerType.DELETE || (type === TriggerType.SET &amp;&amp; Object.prototype.toString.call(target) === &#39;[object Map]&#39;)) {</span></span>
<span class="line"><span>            // 如果目标对象是数组，取出 length 相关的副作用函数</span></span>
<span class="line"><span>            if (type === TriggerType.ADD &amp;&amp; Array.isArray(target)) {</span></span>
<span class="line"><span>                const lengthEffects = depsMap.get(&#39;length&#39;)</span></span>
<span class="line"><span>                lengthEffects &amp;&amp; lengthEffects.forEach(effectFn =&gt; {</span></span>
<span class="line"><span>                    if (effectFn !== activeEffect) {</span></span>
<span class="line"><span>                        effectsToRun.add(effectFn);</span></span>
<span class="line"><span>                    }</span></span>
<span class="line"><span>                });</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            const iteraterEffects = depsMap.get(ITERATE_KEY)</span></span>
<span class="line"><span>            iteraterEffects &amp;&amp; iteraterEffects.forEach(effectFn =&gt; {</span></span>
<span class="line"><span>                // 如果 trigger 触发执行的副函数与当前正在执行的副函数相同</span></span>
<span class="line"><span>                // 说明在副作用函数中同时进行了读取和设置,导致无限循环,栈溢出</span></span>
<span class="line"><span>                // 不触发相同的副作用函数</span></span>
<span class="line"><span>                if (effectFn !== activeEffect) {</span></span>
<span class="line"><span>                    effectsToRun.add(effectFn);</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            });</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        // 只有属性发送新增或删除时并且是 MAP 目标对象，才触发 MAP_KEY_ITERATE_KEY 相关联的副作用函数重新执行</span></span>
<span class="line"><span>        if ((type === TriggerType.ADD || type === TriggerType.DELETE) &amp;&amp; Object.prototype.toString.call(target) === &#39;[object Map]&#39;) {</span></span>
<span class="line"><span>            const iteraterEffects = depsMap.get(MAP_KEY_ITERATE_KEY)</span></span>
<span class="line"><span>            iteraterEffects &amp;&amp; iteraterEffects.forEach(effectFn =&gt; {</span></span>
<span class="line"><span>                // 如果 trigger 触发执行的副函数与当前正在执行的副函数相同</span></span>
<span class="line"><span>                // 说明在副作用函数中同时进行了读取和设置,导致无限循环,栈溢出</span></span>
<span class="line"><span>                // 不触发相同的副作用函数</span></span>
<span class="line"><span>                if (effectFn !== activeEffect) {</span></span>
<span class="line"><span>                    effectsToRun.add(effectFn);</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            });</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        // 如果目标对象是数组，并且修改了 length 属性</span></span>
<span class="line"><span>        if (Array.isArray(target) &amp;&amp; key === &#39;length&#39;) {</span></span>
<span class="line"><span>            // 对应索引值大于或等于新的 length 值的元素，会被删除，因此将其副作用函数加入 effectsToRun 中</span></span>
<span class="line"><span>            depsMap.forEach((deps, depsKey) =&gt; {</span></span>
<span class="line"><span>                if (depsKey &gt;= newVal) {</span></span>
<span class="line"><span>                    deps &amp;&amp; deps.forEach(effectFn =&gt; {</span></span>
<span class="line"><span>                        if (effectFn !== activeEffect) {</span></span>
<span class="line"><span>                            effectsToRun.add(effectFn);</span></span>
<span class="line"><span>                        }</span></span>
<span class="line"><span>                    });</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            })</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        // 把副作用函数从桶里取出并执行</span></span>
<span class="line"><span>        effectsToRun &amp;&amp; effectsToRun.forEach(effectFn =&gt; {</span></span>
<span class="line"><span>            // 如果副作用函数调度器存在,调用调度器并将副作用函数传递</span></span>
<span class="line"><span>            if (effectFn.options.scheduler) {</span></span>
<span class="line"><span>                effectFn.options.scheduler(effectFn);</span></span>
<span class="line"><span>            } else {</span></span>
<span class="line"><span>                effectFn()</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>        });</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // 定义一个任务队列</span></span>
<span class="line"><span>    const jobQueue = new Set();</span></span>
<span class="line"><span>    // 一个标志代表是否正在刷新队列</span></span>
<span class="line"><span>    let isFlushing = false;</span></span>
<span class="line"><span>    // 刷新队列</span></span>
<span class="line"><span>    function flushJob() {</span></span>
<span class="line"><span>        // 如果正在刷新队列，什么都不做</span></span>
<span class="line"><span>        if (isFlushing) return</span></span>
<span class="line"><span>        isFlushing = true</span></span>
<span class="line"><span>        // 创建一个 Promise 实例,用它将一个任务添加到微任务队列</span></span>
<span class="line"><span>        const p = Promise.resolve();</span></span>
<span class="line"><span>        p.then(() =&gt; {</span></span>
<span class="line"><span>            jobQueue.forEach(job =&gt; job())</span></span>
<span class="line"><span>        }).finally(() =&gt; {</span></span>
<span class="line"><span>            // 结束后重置 isFlushing</span></span>
<span class="line"><span>            isFlushing = false</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // 实现计算属性并缓存不变值,实际是一个懒执行的副作用函数</span></span>
<span class="line"><span>    function computed(getter) {</span></span>
<span class="line"><span>        // value 用来缓存上一次计算的值</span></span>
<span class="line"><span>        let value</span></span>
<span class="line"><span>        // 用来标志是否需要重新计算值，为 true 表示“脏”，需要计算</span></span>
<span class="line"><span>        let dirty = true</span></span>
<span class="line"><span>        const effectFn = effect(getter, {</span></span>
<span class="line"><span>            lazy: true,</span></span>
<span class="line"><span>            // 添加调度器，在调度器中重置标志</span></span>
<span class="line"><span>            scheduler() {</span></span>
<span class="line"><span>                if (!dirty) {</span></span>
<span class="line"><span>                    dirty = true</span></span>
<span class="line"><span>                    // 当计算属性依赖的响应式数据变化时，手动调用 trigger 触发响应</span></span>
<span class="line"><span>                    trigger(obj, &#39;value&#39;)</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>        const obj = {</span></span>
<span class="line"><span>            // 当读取 value 时才执行 effectFn</span></span>
<span class="line"><span>            get value() {</span></span>
<span class="line"><span>                // 只有“脏”才计算值，并将得到的值缓存在 value 中</span></span>
<span class="line"><span>                if (dirty) {</span></span>
<span class="line"><span>                    value = effectFn();</span></span>
<span class="line"><span>                    dirty = false;</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>                // 当读取 value 时，手动调用 track 函数进行追踪</span></span>
<span class="line"><span>                track(obj, &#39;value&#39;)</span></span>
<span class="line"><span>                return value</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return obj;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // watch 观测响应式数据, source 是响应式数据， cb 是回调函数</span></span>
<span class="line"><span>    function watch(source, cb, options = {}) {</span></span>
<span class="line"><span>        // 递归读取</span></span>
<span class="line"><span>        function traverse(value, seen = new Set()) {</span></span>
<span class="line"><span>            // 如果要读取的数据是原始值，或者已被读取过，什么都不做</span></span>
<span class="line"><span>            if (typeof value !== &#39;object&#39; || value === null || seen.has(value)) return</span></span>
<span class="line"><span>            // 将数据添加到 seen 中，代表遍历的读取过了，避免死循环</span></span>
<span class="line"><span>            seen.add(value)</span></span>
<span class="line"><span>            // 暂不考虑数组</span></span>
<span class="line"><span>            // 假设 value 就是一个对象</span></span>
<span class="line"><span>            for (const key in value) {</span></span>
<span class="line"><span>                traverse(value[key], seen)</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            return value</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        // 定义 getter</span></span>
<span class="line"><span>        let getter</span></span>
<span class="line"><span>        // 如果 source 是函数，说明用户传递的是 getter ，直接赋值</span></span>
<span class="line"><span>        if (typeof source === &#39;function&#39;) {</span></span>
<span class="line"><span>            getter = source</span></span>
<span class="line"><span>        } else {</span></span>
<span class="line"><span>            // 否则递归读取</span></span>
<span class="line"><span>            getter = () =&gt; traverse(source)</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        // 定义旧值和新值</span></span>
<span class="line"><span>        let newValue, oldValue</span></span>
<span class="line"><span>        // cleanup 用来存储用户注册的过期回调</span></span>
<span class="line"><span>        let cleanup</span></span>
<span class="line"><span>        // 定义 onInvalidate 函数</span></span>
<span class="line"><span>        function onInvalidate(fn) {</span></span>
<span class="line"><span>            // 将过期回调存储到 cleanup 中</span></span>
<span class="line"><span>            cleanup = fn</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        // 提取 scheduler 调度函数为一个独立的 job 函数</span></span>
<span class="line"><span>        function job() {</span></span>
<span class="line"><span>            // 在调度器中执行副作用函数，获得新值</span></span>
<span class="line"><span>            newValue = effectFn()</span></span>
<span class="line"><span>            // 在调用回调函数 cb 前，先调用过期回调</span></span>
<span class="line"><span>            if (cleanup) {</span></span>
<span class="line"><span>                cleanup()</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            // 当数据变化时，调用回调函数，返回旧值和新值</span></span>
<span class="line"><span>            cb(newValue, oldValue, onInvalidate)</span></span>
<span class="line"><span>            // 更新旧值</span></span>
<span class="line"><span>            oldValue = newValue</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        // 触发读取操作，建立联系</span></span>
<span class="line"><span>        const effectFn = effect(() =&gt; getter(), {</span></span>
<span class="line"><span>            lazy: true,</span></span>
<span class="line"><span>            scheduler: () =&gt; {</span></span>
<span class="line"><span>                if (options.flush === &#39;post&#39;) {</span></span>
<span class="line"><span>                    const p = Promise.resolve();</span></span>
<span class="line"><span>                    p.then(job)</span></span>
<span class="line"><span>                } else {</span></span>
<span class="line"><span>                    job()</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>        // 当 immediate 为 true 时，立即执行 job ,从而触发回调执行</span></span>
<span class="line"><span>        if (options.immediate) {</span></span>
<span class="line"><span>            job()</span></span>
<span class="line"><span>        } else {</span></span>
<span class="line"><span>            // 手动调用副作用函数，拿到旧值</span></span>
<span class="line"><span>            oldValue = effectFn()</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    // 对原始值的响应式方案</span></span>
<span class="line"><span>    // 将原始值转化为非原始值</span></span>
<span class="line"><span>    function ref(val) {</span></span>
<span class="line"><span>        // 在函数内部创建包裹对象</span></span>
<span class="line"><span>        const wrapper = {</span></span>
<span class="line"><span>            value: val</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        // 使用 Object.defineProperty 在 wrapper 对象上定义一个不可枚举且不可写的属性 __v_isRef ，并且值为 true</span></span>
<span class="line"><span>        Object.defineProperty(wrapper, &#39;__v_isRef&#39;, {</span></span>
<span class="line"><span>            value: true</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>        // 将包裹对象变成响应式数据</span></span>
<span class="line"><span>        return reactive(wrapper)</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // 批量转换响应式数据</span></span>
<span class="line"><span>    function toRefs(obj) {</span></span>
<span class="line"><span>        const ret = {}</span></span>
<span class="line"><span>        for (const key in obj) {</span></span>
<span class="line"><span>            ret[key] = toRef(obj, key)</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return ret</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // 解决响应丢失问题</span></span>
<span class="line"><span>    // 例：obj=reactive({});newObj={...toRefs(obj)}</span></span>
<span class="line"><span>    function toRef(obj, key) {</span></span>
<span class="line"><span>        // 在函数内部创建包裹对象</span></span>
<span class="line"><span>        const wrapper = {</span></span>
<span class="line"><span>            get value() {</span></span>
<span class="line"><span>                return obj[key]</span></span>
<span class="line"><span>            },</span></span>
<span class="line"><span>            set value(val) {</span></span>
<span class="line"><span>                obj[key] = val</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        // 使用 Object.defineProperty 在 wrapper 对象上定义一个不可枚举且不可写的属性 __v_isRef ，并且值为 true</span></span>
<span class="line"><span>        Object.defineProperty(wrapper, &#39;__v_isRef&#39;, {</span></span>
<span class="line"><span>            value: true</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>        // 将包裹对象变成响应式数据</span></span>
<span class="line"><span>        return wrapper</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // 使用时自动脱 ref</span></span>
<span class="line"><span>    // 例：&lt;p&gt;{{foo}}&lt;/p&gt; 而非 &lt;p&gt;{{foo.value}}&lt;/p&gt;</span></span>
<span class="line"><span>    // 例：obj=reactive({});newObj=proxyRefs({...toRefs(obj)})</span></span>
<span class="line"><span>    function proxyRefs(target) {</span></span>
<span class="line"><span>        return new Proxy(target, {</span></span>
<span class="line"><span>            get(target, key, receiver) {</span></span>
<span class="line"><span>                const value = Reflect.get(target, key, receiver)</span></span>
<span class="line"><span>                return value.__v_isRef ? value.value : value</span></span>
<span class="line"><span>            },</span></span>
<span class="line"><span>            set(target, key, newVal, receiver) {</span></span>
<span class="line"><span>                // 获取真实值</span></span>
<span class="line"><span>                const value = target[key]</span></span>
<span class="line"><span>                // 如果是 ref ,设置其对应的 value 属性值</span></span>
<span class="line"><span>                if (value.__v_isRef) {</span></span>
<span class="line"><span>                    value.value = newVal</span></span>
<span class="line"><span>                    return true</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>                return Reflect.set(target, key, newVal, receiver)</span></span>
<span class="line"><span>            },</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    function main() {</span></span>
<span class="line"><span>        // 原始数据</span></span>
<span class="line"><span>        const data = {</span></span>
<span class="line"><span>            ok: true,</span></span>
<span class="line"><span>            text: 1,</span></span>
<span class="line"><span>            foo: 1,</span></span>
<span class="line"><span>            bar: 1,</span></span>
<span class="line"><span>            get getBar() {</span></span>
<span class="line"><span>                return this.bar</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        const proto = {}</span></span>
<span class="line"><span>        // 对原始数据的代理，每次访问及更改时进行处理</span></span>
<span class="line"><span>        const obj = reactive(data)</span></span>
<span class="line"><span>        const parent = reactive(proto)</span></span>
<span class="line"><span>        // 使用 parent 作为 obj 的原型</span></span>
<span class="line"><span>        Object.setPrototypeOf(obj, parent)</span></span>
<span class="line"><span>        // 基本函数</span></span>
<span class="line"><span>        function basicFn() {</span></span>
<span class="line"><span>            effect(() =&gt; {</span></span>
<span class="line"><span>                // 加入 Reflect 后 this 指向 obj , 否则为 data</span></span>
<span class="line"><span>                obj.getBar;</span></span>
<span class="line"><span>                &#39;foo&#39; in obj;</span></span>
<span class="line"><span>            })</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        const p2 = new Proxy(basicFn, {</span></span>
<span class="line"><span>            // 使用 apply 拦截函数调用</span></span>
<span class="line"><span>            apply(target, thisArg, argArray) {</span></span>
<span class="line"><span>                target.call(thisArg, ...argArray)</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>        // 执行注册副作用函数，触发读取即绑定副作用</span></span>
<span class="line"><span>        const effectFn = effect(() =&gt; {</span></span>
<span class="line"><span>            // 当 ok 为 true 时第一次执行读取，将 ok 和 text 进行读取</span></span>
<span class="line"><span>            // 此时 ok 和 text 建立了关联关系</span></span>
<span class="line"><span>            // bucket.obj.ok =[ok:effectFn];ok:effectFn.effects=[bucket.obj.ok]</span></span>
<span class="line"><span>            // bucket.obj.text =[text:effectFn];text:effectFn.effects=[bucket.obj.text]</span></span>
<span class="line"><span>            // 修改 ok 为 false 时,首先清除当前副作用 bucket.obj.ok[effectFn] 和 effectFn.effects</span></span>
<span class="line"><span>            // 然后触发副作用修改 document , 此时重新建立 ok 的关联关系</span></span>
<span class="line"><span>            // 由于 ok 为 false 因此 obj.text 不读取,而它的关联关系还在</span></span>
<span class="line"><span>            // 修改 text 为 2 时,首先清除当前副作用 bucket.obj.ok[effectFn] 和 effectFn.effects</span></span>
<span class="line"><span>            // 然后触发副作用修改 document , 由于 ok 为 false ,因此 text 无法被读取无法关联副作用</span></span>
<span class="line"><span>            // 修改 text 为 3 时,无副作用</span></span>
<span class="line"><span>            // 综上，在副作用里要先清除之前的副作用关联，并建立新的关联，如果无法建立，则此属性无副作用</span></span>
<span class="line"><span>            document.body.innerText = obj.ok ? obj.text : &#39;not&#39;;</span></span>
<span class="line"><span>            return obj.foo + obj.bar</span></span>
<span class="line"><span>        }, {</span></span>
<span class="line"><span>            // 懒执行</span></span>
<span class="line"><span>            lazy: true,</span></span>
<span class="line"><span>            // 调度器</span></span>
<span class="line"><span>            scheduler(fn) {</span></span>
<span class="line"><span>                // 每次调度时将副作用函数添加到 jobQueue 队列中</span></span>
<span class="line"><span>                jobQueue.add(fn)</span></span>
<span class="line"><span>                // 调用 flushJob 刷新队列</span></span>
<span class="line"><span>                flushJob()</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        });</span></span>
<span class="line"><span>        // 手动加载懒执行的副作用</span></span>
<span class="line"><span>        const value = effectFn()</span></span>
<span class="line"><span>        // 1 秒后修改响应式数据</span></span>
<span class="line"><span>        setTimeout(() =&gt; {</span></span>
<span class="line"><span>            obj.ok = false;</span></span>
<span class="line"><span>            obj.text = 2;</span></span>
<span class="line"><span>            obj.text = 3;</span></span>
<span class="line"><span>            obj.noExist = &#39;good&#39;;</span></span>
<span class="line"><span>        }, 1 * 1000)</span></span>
<span class="line"><span>        // 测试计算属性</span></span>
<span class="line"><span>        const sumRes = computed(() =&gt; obj.foo + obj.bar)</span></span>
<span class="line"><span>        console.log(sumRes.value);</span></span>
<span class="line"><span>        // 测试嵌套副作用下的计算属性</span></span>
<span class="line"><span>        effect(() =&gt; {</span></span>
<span class="line"><span>            console.log(sumRes.value);</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>        // 测试 watch 监听数据变化和立即执行</span></span>
<span class="line"><span>        watch(obj, () =&gt; {</span></span>
<span class="line"><span>            console.log(&#39;数据变化了&#39;);</span></span>
<span class="line"><span>        }, {</span></span>
<span class="line"><span>            // 回调函数会在 watch 函数创建时立即执行一次</span></span>
<span class="line"><span>            immediate: true,</span></span>
<span class="line"><span>            // 指定调度函数的执行时机</span></span>
<span class="line"><span>            // pre 组件更新前执行</span></span>
<span class="line"><span>            // post 组件更新后执行，代表调度函数需要将副作用函数放到一个微任务队列中，并等待DOM更新结束后执行</span></span>
<span class="line"><span>            // sync 同步执行</span></span>
<span class="line"><span>            flush: &#39;pre&#39;</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>        // 测试 watch 竟态问题，即副作用函数过期问题</span></span>
<span class="line"><span>        let finalData;</span></span>
<span class="line"><span>        watch(() =&gt; obj.foo, async (newValue, oldValue, onInvalidate) =&gt; {</span></span>
<span class="line"><span>            console.log(newValue, oldValue)</span></span>
<span class="line"><span>            // 定义一个标志，代表当前副作用函数是否过期，默认为 false ，代表没有过期</span></span>
<span class="line"><span>            let expired = false</span></span>
<span class="line"><span>            // 注册过期回调</span></span>
<span class="line"><span>            onInvalidate(() =&gt; {</span></span>
<span class="line"><span>                // 当过期时，将标志置为 true </span></span>
<span class="line"><span>                expired = true</span></span>
<span class="line"><span>            })</span></span>
<span class="line"><span>            // 发送网络请求</span></span>
<span class="line"><span>            const res = await fetch(&#39;/login&#39;)</span></span>
<span class="line"><span>            // 只有没有过期，才执行后续操作</span></span>
<span class="line"><span>            if (!expired) {</span></span>
<span class="line"><span>                finalData = res;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>        obj.foo++</span></span>
<span class="line"><span>        setTimeout(() =&gt; {</span></span>
<span class="line"><span>            obj.foo++</span></span>
<span class="line"><span>        }, 200)</span></span>
<span class="line"><span>    }</span></span></code></pre></div></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-e257564d><!--[--><!--]--><!----><!----></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter" data-v-5d98c3a5 data-v-e315a0ad><div class="container" data-v-e315a0ad><p class="message" data-v-e315a0ad>思维垃圾</p><p class="copyright" data-v-e315a0ad>Copyright © 2024present v123ve</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"CSms-AAW\",\"zh-cn_学习笔记_23种设计模式(6).md\":\"CfnkgiL_\",\"zh-cn_学习笔记_annatation注解.md\":\"DohaOjfH\",\"zh-cn_学习笔记_apache shiro.md\":\"2k-CHfMQ\",\"zh-cn_学习笔记_binaryinsertsort.java.md\":\"Bs4_bfAB\",\"zh-cn_学习笔记_ioc 控制反转（inversion of control）.md\":\"BQyLiUQ2\",\"zh-cn_学习笔记_java-web工程.md\":\"BTnTYYvQ\",\"zh-cn_学习笔记_java相关.md\":\"D-VV41RM\",\"zh-cn_学习笔记_java高级特性.md\":\"FIMFqxdV\",\"zh-cn_学习笔记_jdbc.md\":\"h4iQqjhf\",\"zh-cn_学习笔记_linux.md\":\"CYYk6FE8\",\"zh-cn_学习笔记_mybatis.md\":\"DKeKkYhy\",\"zh-cn_学习笔记_myxml.md\":\"E6TrQh99\",\"zh-cn_学习笔记_nginx简介.md\":\"C-ghxRS5\",\"zh-cn_学习笔记_redis.md\":\"CR_IJDYS\",\"zh-cn_学习笔记_shell编程.md\":\"BhhlO2vF\",\"zh-cn_学习笔记_socket tcp udp.md\":\"DjZQqRep\",\"zh-cn_学习笔记_spring boot.md\":\"C7sxpYpu\",\"zh-cn_学习笔记_spring mvc 多线程并发.md\":\"DVJgzjdD\",\"zh-cn_学习笔记_springboot.md\":\"BonNz02Y\",\"zh-cn_学习笔记_springmvc的配置：.md\":\"CATzlb6D\",\"zh-cn_学习笔记_spring定时任务.md\":\"DT1E8JDo\",\"zh-cn_学习笔记_spring简介.md\":\"DM5bhVB0\",\"zh-cn_学习笔记_swagger.md\":\"BJOgFJWd\",\"zh-cn_学习笔记_web.xml.md\":\"B5KBRFV6\",\"zh-cn_学习笔记_zookeeper.md\":\"CQiVodbQ\",\"zh-cn_学习笔记_二期.md\":\"B31c9co_\",\"zh-cn_学习笔记_代理模式.md\":\"CN8gZjK0\",\"zh-cn_学习笔记_使用heritrix 爬取网络资源.md\":\"COuBkHMd\",\"zh-cn_学习笔记_分布式微服务架构原理.md\":\"ngjaiU4f\",\"zh-cn_学习笔记_分布式搜索框架es.md\":\"Cl0Bbev_\",\"zh-cn_学习笔记_分布式消息队列kafka.md\":\"BXK9VYqP\",\"zh-cn_学习笔记_四大金刚.md\":\"Di6lIJKW\",\"zh-cn_学习笔记_在js中获取文件点之后的后缀字符.md\":\"Ciy9Jwaz\",\"zh-cn_学习笔记_大数据.md\":\"CgCMJqQG\",\"zh-cn_学习笔记_排序.md\":\"CgcQGfzP\",\"zh-cn_学习笔记_获取行政区范围.md\":\"BHaa3bdv\",\"zh-cn_学习笔记_菱形.md\":\"BRO0jlcW\",\"zh-cn_学习笔记_进程和线程的区别：.md\":\"DCy-dnv2\",\"zh-cn_学习笔记_零xml配置ss.md\":\"DIuhJE8A\",\"zh-cn_学习笔记_零配置ssm框架整合.md\":\"BzkxQVP5\",\"zh-cn_学习笔记_面试经验.md\":\"CWGDmOnf\",\"zh-cn_工作笔记_ad-grid按无、符号、数字、字母、中文排序.md\":\"ltDm75yy\",\"zh-cn_工作笔记_codemirror.md\":\"BpehgFwc\",\"zh-cn_工作笔记_content图标库.md\":\"CHpxQe6p\",\"zh-cn_工作笔记_css常用操作.md\":\"NVL53xEI\",\"zh-cn_工作笔记_css酷炫实现.md\":\"DcAwKEuI\",\"zh-cn_工作笔记_docker.md\":\"k3aLdZgI\",\"zh-cn_工作笔记_dumi.md\":\"wCj8_RZa\",\"zh-cn_工作笔记_easy-ui常用操作.md\":\"D5E_VY4d\",\"zh-cn_工作笔记_es6多继承.md\":\"BJC-Ajbw\",\"zh-cn_工作笔记_idea设置教程.md\":\"BsYet_qs\",\"zh-cn_工作笔记_iframe跨域.md\":\"Be6YAcLh\",\"zh-cn_工作笔记_javautils.md\":\"ChHc03Z7\",\"zh-cn_工作笔记_java常用操作.md\":\"KpFEocJF\",\"zh-cn_工作笔记_js常用操作.md\":\"BnSFmztT\",\"zh-cn_工作笔记_js生成树.md\":\"C5TRMSQn\",\"zh-cn_工作笔记_less.md\":\"B2S4QAvz\",\"zh-cn_工作笔记_listary集成everything.md\":\"DxddgJNv\",\"zh-cn_工作笔记_lodash.md\":\"Oe4ysgDd\",\"zh-cn_工作笔记_mock示例.md\":\"CQxR8-eb\",\"zh-cn_工作笔记_nginx不缓存设置.md\":\"DZMLWmwi\",\"zh-cn_工作笔记_nginx正则取反.md\":\"-1kfArTZ\",\"zh-cn_工作笔记_nodejs和webpack.md\":\"CBwcSn5W\",\"zh-cn_工作笔记_react常用操作.md\":\"D8Q5NaUn\",\"zh-cn_工作笔记_react高级.md\":\"xuzInWC9\",\"zh-cn_工作笔记_samba.md\":\"B0WwTcpU\",\"zh-cn_工作笔记_sql相关.md\":\"C61RJvX0\",\"zh-cn_工作笔记_umi2_pnpm.md\":\"D3WqPFLp\",\"zh-cn_工作笔记_videocommon.md\":\"ympQV7SZ\",\"zh-cn_工作笔记_vscode.md\":\"BN45ArKO\",\"zh-cn_工作笔记_webpack代码混淆.md\":\"DQ-lPzaW\",\"zh-cn_工作笔记_websocket.md\":\"CZdPw4NE\",\"zh-cn_工作笔记_windows常用操作.md\":\"BRtyzg-I\",\"zh-cn_工作笔记_创建offer.md\":\"DHt0uPNb\",\"zh-cn_工作笔记_前端开发环境部署.md\":\"CnvWgEAf\",\"zh-cn_工作笔记_加密解密.md\":\"BoOdlfl-\",\"zh-cn_工作笔记_叉号.md\":\"DmOyyn9I\",\"zh-cn_工作笔记_双击处理.md\":\"CP0BMNGV\",\"zh-cn_工作笔记_向量叉乘.md\":\"BccQloYH\",\"zh-cn_工作笔记_响应系统的作用与实现.md\":\"FBjfpL_B\",\"zh-cn_工作笔记_奇偶岸边.md\":\"YqFsH-HK\",\"zh-cn_工作笔记_安装.md\":\"CYszrS21\",\"zh-cn_工作笔记_排序和树.md\":\"C4vdRs5c\",\"zh-cn_工作笔记_文件下载.md\":\"D1OHaD0g\",\"zh-cn_工作笔记_渲染器和diff算法.md\":\"tEjhmHL0\",\"zh-cn_工作笔记_生成饼状图.md\":\"DuBFzH43\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"v123ve\",\"description\":\"思维垃圾\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"footer\":{\"message\":\"思维垃圾\",\"copyright\":\"Copyright © 2024present v123ve\"},\"logo\":\"/v-logo.png\",\"i18nRouting\":true,\"search\":{\"provider\":\"local\",\"options\":{\"locales\":{\"zh-CN\":{\"translations\":{\"button\":{\"buttonText\":\"搜索\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"displayDetails\":\"显示详细列表\",\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询结果\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}},\"en-US\":{\"translations\":{\"button\":{\"buttonText\":\"Search\",\"buttonAriaLabel\":\"Search for Documents\"},\"modal\":{\"displayDetails\":\"Display detailed list\",\"noResultsText\":\"Unable to find relevant results\",\"resetButtonTitle\":\"Clear Query Results\",\"footer\":{\"selectText\":\"select\",\"navigateText\":\"switch\",\"closeText\":\"close\"}}}}}}},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/vuejs/vitepress\"}]},\"locales\":{\"root\":{\"label\":\"简体中文\",\"lang\":\"zh-CN\",\"link\":\"/\",\"description\":\"思维垃圾\",\"title\":\"v123ve\",\"themeConfig\":{\"darkModeSwitchLabel\":\"主题\",\"docFooter\":{\"prev\":\"上一篇\",\"next\":\"下一篇\"},\"lastUpdatedText\":\"最后更新\",\"nav\":[{\"text\":\"主页\",\"link\":\"/\"},{\"text\":\"学习笔记\",\"items\":[{\"text\":\"23种设计模式(6)\",\"link\":\"/zh-CN/学习笔记/23种设计模式(6)\"},{\"text\":\"annatation注解\",\"link\":\"/zh-CN/学习笔记/annatation注解\"},{\"text\":\"Apache Shiro\",\"link\":\"/zh-CN/学习笔记/Apache Shiro\"},{\"text\":\"BinaryInsertSort.java\",\"link\":\"/zh-CN/学习笔记/BinaryInsertSort.java\"},{\"text\":\"IOC 控制反转（inversion of control）\",\"link\":\"/zh-CN/学习笔记/IOC 控制反转（inversion of control）\"},{\"text\":\"java-web工程\",\"link\":\"/zh-CN/学习笔记/java-web工程\"},{\"text\":\"java相关\",\"link\":\"/zh-CN/学习笔记/java相关\"},{\"text\":\"java高级特性\",\"link\":\"/zh-CN/学习笔记/java高级特性\"},{\"text\":\"jdbc\",\"link\":\"/zh-CN/学习笔记/jdbc\"},{\"text\":\"linux\",\"link\":\"/zh-CN/学习笔记/linux\"},{\"text\":\"mybatis\",\"link\":\"/zh-CN/学习笔记/mybatis\"},{\"text\":\"myxml\",\"link\":\"/zh-CN/学习笔记/myxml\"},{\"text\":\"nginx简介\",\"link\":\"/zh-CN/学习笔记/nginx简介\"},{\"text\":\"Redis\",\"link\":\"/zh-CN/学习笔记/Redis\"},{\"text\":\"shell编程\",\"link\":\"/zh-CN/学习笔记/shell编程\"},{\"text\":\"socket tcp udp\",\"link\":\"/zh-CN/学习笔记/socket tcp udp\"},{\"text\":\"Spring Boot\",\"link\":\"/zh-CN/学习笔记/Spring Boot\"},{\"text\":\"spring mvc 多线程并发\",\"link\":\"/zh-CN/学习笔记/spring mvc 多线程并发\"},{\"text\":\"SpringBoot\",\"link\":\"/zh-CN/学习笔记/SpringBoot\"},{\"text\":\"springmvc的配置：\",\"link\":\"/zh-CN/学习笔记/springmvc的配置：\"},{\"text\":\"spring定时任务\",\"link\":\"/zh-CN/学习笔记/spring定时任务\"},{\"text\":\"spring简介\",\"link\":\"/zh-CN/学习笔记/spring简介\"},{\"text\":\"Swagger\",\"link\":\"/zh-CN/学习笔记/Swagger\"},{\"text\":\"web.xml\",\"link\":\"/zh-CN/学习笔记/web.xml\"},{\"text\":\"Zookeeper\",\"link\":\"/zh-CN/学习笔记/Zookeeper\"},{\"text\":\"二期\",\"link\":\"/zh-CN/学习笔记/二期\"},{\"text\":\"代理模式\",\"link\":\"/zh-CN/学习笔记/代理模式\"},{\"text\":\"使用Heritrix 爬取网络资源\",\"link\":\"/zh-CN/学习笔记/使用Heritrix 爬取网络资源\"},{\"text\":\"分布式微服务架构原理\",\"link\":\"/zh-CN/学习笔记/分布式微服务架构原理\"},{\"text\":\"分布式搜索框架ES\",\"link\":\"/zh-CN/学习笔记/分布式搜索框架ES\"},{\"text\":\"分布式消息队列kafka\",\"link\":\"/zh-CN/学习笔记/分布式消息队列kafka\"},{\"text\":\"四大金刚\",\"link\":\"/zh-CN/学习笔记/四大金刚\"},{\"text\":\"在JS中获取文件点之后的后缀字符\",\"link\":\"/zh-CN/学习笔记/在JS中获取文件点之后的后缀字符\"},{\"text\":\"大数据\",\"link\":\"/zh-CN/学习笔记/大数据\"},{\"text\":\"排序\",\"link\":\"/zh-CN/学习笔记/排序\"},{\"text\":\"获取行政区范围\",\"link\":\"/zh-CN/学习笔记/获取行政区范围\"},{\"text\":\"菱形\",\"link\":\"/zh-CN/学习笔记/菱形\"},{\"text\":\"进程和线程的区别：\",\"link\":\"/zh-CN/学习笔记/进程和线程的区别：\"},{\"text\":\"零XML配置ss\",\"link\":\"/zh-CN/学习笔记/零XML配置ss\"},{\"text\":\"零配置ssm框架整合\",\"link\":\"/zh-CN/学习笔记/零配置ssm框架整合\"},{\"text\":\"面试经验\",\"link\":\"/zh-CN/学习笔记/面试经验\"}]},{\"text\":\"工作笔记\",\"items\":[{\"text\":\"ad-grid按无、符号、数字、字母、中文排序\",\"link\":\"/zh-CN/工作笔记/ad-grid按无、符号、数字、字母、中文排序\"},{\"text\":\"CodeMirror\",\"link\":\"/zh-CN/工作笔记/CodeMirror\"},{\"text\":\"content图标库\",\"link\":\"/zh-CN/工作笔记/content图标库\"},{\"text\":\"CSS常用操作\",\"link\":\"/zh-CN/工作笔记/CSS常用操作\"},{\"text\":\"CSS酷炫实现\",\"link\":\"/zh-CN/工作笔记/CSS酷炫实现\"},{\"text\":\"Docker\",\"link\":\"/zh-CN/工作笔记/Docker\"},{\"text\":\"dumi\",\"link\":\"/zh-CN/工作笔记/dumi\"},{\"text\":\"easy-ui常用操作\",\"link\":\"/zh-CN/工作笔记/easy-ui常用操作\"},{\"text\":\"ES6多继承\",\"link\":\"/zh-CN/工作笔记/ES6多继承\"},{\"text\":\"idea设置教程\",\"link\":\"/zh-CN/工作笔记/idea设置教程\"},{\"text\":\"iframe跨域\",\"link\":\"/zh-CN/工作笔记/iframe跨域\"},{\"text\":\"JavaUtils\",\"link\":\"/zh-CN/工作笔记/JavaUtils\"},{\"text\":\"java常用操作\",\"link\":\"/zh-CN/工作笔记/java常用操作\"},{\"text\":\"js常用操作\",\"link\":\"/zh-CN/工作笔记/js常用操作\"},{\"text\":\"js生成树\",\"link\":\"/zh-CN/工作笔记/js生成树\"},{\"text\":\"less\",\"link\":\"/zh-CN/工作笔记/less\"},{\"text\":\"listary集成everything\",\"link\":\"/zh-CN/工作笔记/listary集成everything\"},{\"text\":\"lodash\",\"link\":\"/zh-CN/工作笔记/lodash\"},{\"text\":\"mock示例\",\"link\":\"/zh-CN/工作笔记/mock示例\"},{\"text\":\"nginx不缓存设置\",\"link\":\"/zh-CN/工作笔记/nginx不缓存设置\"},{\"text\":\"nginx正则取反\",\"link\":\"/zh-CN/工作笔记/nginx正则取反\"},{\"text\":\"NodeJs和WebPack\",\"link\":\"/zh-CN/工作笔记/NodeJs和WebPack\"},{\"text\":\"React常用操作\",\"link\":\"/zh-CN/工作笔记/React常用操作\"},{\"text\":\"React高级\",\"link\":\"/zh-CN/工作笔记/React高级\"},{\"text\":\"samba\",\"link\":\"/zh-CN/工作笔记/samba\"},{\"text\":\"Sql相关\",\"link\":\"/zh-CN/工作笔记/Sql相关\"},{\"text\":\"umi2_pnpm\",\"link\":\"/zh-CN/工作笔记/umi2_pnpm\"},{\"text\":\"VideoCommon\",\"link\":\"/zh-CN/工作笔记/VideoCommon\"},{\"text\":\"VSCode\",\"link\":\"/zh-CN/工作笔记/VSCode\"},{\"text\":\"Webpack代码混淆\",\"link\":\"/zh-CN/工作笔记/Webpack代码混淆\"},{\"text\":\"WebSocket\",\"link\":\"/zh-CN/工作笔记/WebSocket\"},{\"text\":\"windows常用操作\",\"link\":\"/zh-CN/工作笔记/windows常用操作\"},{\"text\":\"创建offer\",\"link\":\"/zh-CN/工作笔记/创建offer\"},{\"text\":\"前端开发环境部署\",\"link\":\"/zh-CN/工作笔记/前端开发环境部署\"},{\"text\":\"加密解密\",\"link\":\"/zh-CN/工作笔记/加密解密\"},{\"text\":\"叉号\",\"link\":\"/zh-CN/工作笔记/叉号\"},{\"text\":\"双击处理\",\"link\":\"/zh-CN/工作笔记/双击处理\"},{\"text\":\"向量叉乘\",\"link\":\"/zh-CN/工作笔记/向量叉乘\"},{\"text\":\"响应系统的作用与实现\",\"link\":\"/zh-CN/工作笔记/响应系统的作用与实现\"},{\"text\":\"奇偶岸边\",\"link\":\"/zh-CN/工作笔记/奇偶岸边\"},{\"text\":\"安装\",\"link\":\"/zh-CN/工作笔记/安装\"},{\"text\":\"排序和树\",\"link\":\"/zh-CN/工作笔记/排序和树\"},{\"text\":\"文件下载\",\"link\":\"/zh-CN/工作笔记/文件下载\"},{\"text\":\"渲染器和Diff算法\",\"link\":\"/zh-CN/工作笔记/渲染器和Diff算法\"},{\"text\":\"生成饼状图\",\"link\":\"/zh-CN/工作笔记/生成饼状图\"}]},{\"text\":\"记录笔记\",\"items\":[]}],\"outline\":{\"level\":[2,6],\"label\":\"目录\"},\"returnToTopLabel\":\"返回顶部\",\"sidebarMenuLabel\":\"菜单\",\"sidebar\":{\"/zh-CN/docs/学习笔记/\":[{\"text\":\"学习笔记\",\"collapsed\":true,\"items\":[{\"text\":\"23种设计模式(6)\",\"link\":\"/zh-CN/学习笔记/23种设计模式(6)\"},{\"text\":\"annatation注解\",\"link\":\"/zh-CN/学习笔记/annatation注解\"},{\"text\":\"Apache Shiro\",\"link\":\"/zh-CN/学习笔记/Apache Shiro\"},{\"text\":\"BinaryInsertSort.java\",\"link\":\"/zh-CN/学习笔记/BinaryInsertSort.java\"},{\"text\":\"IOC 控制反转（inversion of control）\",\"link\":\"/zh-CN/学习笔记/IOC 控制反转（inversion of control）\"},{\"text\":\"java-web工程\",\"link\":\"/zh-CN/学习笔记/java-web工程\"},{\"text\":\"java相关\",\"link\":\"/zh-CN/学习笔记/java相关\"},{\"text\":\"java高级特性\",\"link\":\"/zh-CN/学习笔记/java高级特性\"},{\"text\":\"jdbc\",\"link\":\"/zh-CN/学习笔记/jdbc\"},{\"text\":\"linux\",\"link\":\"/zh-CN/学习笔记/linux\"},{\"text\":\"mybatis\",\"link\":\"/zh-CN/学习笔记/mybatis\"},{\"text\":\"myxml\",\"link\":\"/zh-CN/学习笔记/myxml\"},{\"text\":\"nginx简介\",\"link\":\"/zh-CN/学习笔记/nginx简介\"},{\"text\":\"Redis\",\"link\":\"/zh-CN/学习笔记/Redis\"},{\"text\":\"shell编程\",\"link\":\"/zh-CN/学习笔记/shell编程\"},{\"text\":\"socket tcp udp\",\"link\":\"/zh-CN/学习笔记/socket tcp udp\"},{\"text\":\"Spring Boot\",\"link\":\"/zh-CN/学习笔记/Spring Boot\"},{\"text\":\"spring mvc 多线程并发\",\"link\":\"/zh-CN/学习笔记/spring mvc 多线程并发\"},{\"text\":\"SpringBoot\",\"link\":\"/zh-CN/学习笔记/SpringBoot\"},{\"text\":\"springmvc的配置：\",\"link\":\"/zh-CN/学习笔记/springmvc的配置：\"},{\"text\":\"spring定时任务\",\"link\":\"/zh-CN/学习笔记/spring定时任务\"},{\"text\":\"spring简介\",\"link\":\"/zh-CN/学习笔记/spring简介\"},{\"text\":\"Swagger\",\"link\":\"/zh-CN/学习笔记/Swagger\"},{\"text\":\"web.xml\",\"link\":\"/zh-CN/学习笔记/web.xml\"},{\"text\":\"Zookeeper\",\"link\":\"/zh-CN/学习笔记/Zookeeper\"},{\"text\":\"二期\",\"link\":\"/zh-CN/学习笔记/二期\"},{\"text\":\"代理模式\",\"link\":\"/zh-CN/学习笔记/代理模式\"},{\"text\":\"使用Heritrix 爬取网络资源\",\"link\":\"/zh-CN/学习笔记/使用Heritrix 爬取网络资源\"},{\"text\":\"分布式微服务架构原理\",\"link\":\"/zh-CN/学习笔记/分布式微服务架构原理\"},{\"text\":\"分布式搜索框架ES\",\"link\":\"/zh-CN/学习笔记/分布式搜索框架ES\"},{\"text\":\"分布式消息队列kafka\",\"link\":\"/zh-CN/学习笔记/分布式消息队列kafka\"},{\"text\":\"四大金刚\",\"link\":\"/zh-CN/学习笔记/四大金刚\"},{\"text\":\"在JS中获取文件点之后的后缀字符\",\"link\":\"/zh-CN/学习笔记/在JS中获取文件点之后的后缀字符\"},{\"text\":\"大数据\",\"link\":\"/zh-CN/学习笔记/大数据\"},{\"text\":\"排序\",\"link\":\"/zh-CN/学习笔记/排序\"},{\"text\":\"获取行政区范围\",\"link\":\"/zh-CN/学习笔记/获取行政区范围\"},{\"text\":\"菱形\",\"link\":\"/zh-CN/学习笔记/菱形\"},{\"text\":\"进程和线程的区别：\",\"link\":\"/zh-CN/学习笔记/进程和线程的区别：\"},{\"text\":\"零XML配置ss\",\"link\":\"/zh-CN/学习笔记/零XML配置ss\"},{\"text\":\"零配置ssm框架整合\",\"link\":\"/zh-CN/学习笔记/零配置ssm框架整合\"},{\"text\":\"面试经验\",\"link\":\"/zh-CN/学习笔记/面试经验\"}]}],\"/zh-CN/docs/工作笔记/\":[{\"text\":\"工作笔记\",\"collapsed\":true,\"items\":[{\"text\":\"ad-grid按无、符号、数字、字母、中文排序\",\"link\":\"/zh-CN/工作笔记/ad-grid按无、符号、数字、字母、中文排序\"},{\"text\":\"CodeMirror\",\"link\":\"/zh-CN/工作笔记/CodeMirror\"},{\"text\":\"content图标库\",\"link\":\"/zh-CN/工作笔记/content图标库\"},{\"text\":\"CSS常用操作\",\"link\":\"/zh-CN/工作笔记/CSS常用操作\"},{\"text\":\"CSS酷炫实现\",\"link\":\"/zh-CN/工作笔记/CSS酷炫实现\"},{\"text\":\"Docker\",\"link\":\"/zh-CN/工作笔记/Docker\"},{\"text\":\"dumi\",\"link\":\"/zh-CN/工作笔记/dumi\"},{\"text\":\"easy-ui常用操作\",\"link\":\"/zh-CN/工作笔记/easy-ui常用操作\"},{\"text\":\"ES6多继承\",\"link\":\"/zh-CN/工作笔记/ES6多继承\"},{\"text\":\"idea设置教程\",\"link\":\"/zh-CN/工作笔记/idea设置教程\"},{\"text\":\"iframe跨域\",\"link\":\"/zh-CN/工作笔记/iframe跨域\"},{\"text\":\"JavaUtils\",\"link\":\"/zh-CN/工作笔记/JavaUtils\"},{\"text\":\"java常用操作\",\"link\":\"/zh-CN/工作笔记/java常用操作\"},{\"text\":\"js常用操作\",\"link\":\"/zh-CN/工作笔记/js常用操作\"},{\"text\":\"js生成树\",\"link\":\"/zh-CN/工作笔记/js生成树\"},{\"text\":\"less\",\"link\":\"/zh-CN/工作笔记/less\"},{\"text\":\"listary集成everything\",\"link\":\"/zh-CN/工作笔记/listary集成everything\"},{\"text\":\"lodash\",\"link\":\"/zh-CN/工作笔记/lodash\"},{\"text\":\"mock示例\",\"link\":\"/zh-CN/工作笔记/mock示例\"},{\"text\":\"nginx不缓存设置\",\"link\":\"/zh-CN/工作笔记/nginx不缓存设置\"},{\"text\":\"nginx正则取反\",\"link\":\"/zh-CN/工作笔记/nginx正则取反\"},{\"text\":\"NodeJs和WebPack\",\"link\":\"/zh-CN/工作笔记/NodeJs和WebPack\"},{\"text\":\"React常用操作\",\"link\":\"/zh-CN/工作笔记/React常用操作\"},{\"text\":\"React高级\",\"link\":\"/zh-CN/工作笔记/React高级\"},{\"text\":\"samba\",\"link\":\"/zh-CN/工作笔记/samba\"},{\"text\":\"Sql相关\",\"link\":\"/zh-CN/工作笔记/Sql相关\"},{\"text\":\"umi2_pnpm\",\"link\":\"/zh-CN/工作笔记/umi2_pnpm\"},{\"text\":\"VideoCommon\",\"link\":\"/zh-CN/工作笔记/VideoCommon\"},{\"text\":\"VSCode\",\"link\":\"/zh-CN/工作笔记/VSCode\"},{\"text\":\"Webpack代码混淆\",\"link\":\"/zh-CN/工作笔记/Webpack代码混淆\"},{\"text\":\"WebSocket\",\"link\":\"/zh-CN/工作笔记/WebSocket\"},{\"text\":\"windows常用操作\",\"link\":\"/zh-CN/工作笔记/windows常用操作\"},{\"text\":\"创建offer\",\"link\":\"/zh-CN/工作笔记/创建offer\"},{\"text\":\"前端开发环境部署\",\"link\":\"/zh-CN/工作笔记/前端开发环境部署\"},{\"text\":\"加密解密\",\"link\":\"/zh-CN/工作笔记/加密解密\"},{\"text\":\"叉号\",\"link\":\"/zh-CN/工作笔记/叉号\"},{\"text\":\"双击处理\",\"link\":\"/zh-CN/工作笔记/双击处理\"},{\"text\":\"向量叉乘\",\"link\":\"/zh-CN/工作笔记/向量叉乘\"},{\"text\":\"响应系统的作用与实现\",\"link\":\"/zh-CN/工作笔记/响应系统的作用与实现\"},{\"text\":\"奇偶岸边\",\"link\":\"/zh-CN/工作笔记/奇偶岸边\"},{\"text\":\"安装\",\"link\":\"/zh-CN/工作笔记/安装\"},{\"text\":\"排序和树\",\"link\":\"/zh-CN/工作笔记/排序和树\"},{\"text\":\"文件下载\",\"link\":\"/zh-CN/工作笔记/文件下载\"},{\"text\":\"渲染器和Diff算法\",\"link\":\"/zh-CN/工作笔记/渲染器和Diff算法\"},{\"text\":\"生成饼状图\",\"link\":\"/zh-CN/工作笔记/生成饼状图\"}]}],\"/zh-CN/docs/记录笔记/\":[{\"text\":\"记录笔记\",\"collapsed\":true,\"items\":[]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/vuejs/vitepress\"}],\"search\":{\"provider\":\"local\",\"options\":{\"locales\":{\"zh-CN\":{\"translations\":{\"button\":{\"buttonText\":\"搜索\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"displayDetails\":\"显示详细列表\",\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询结果\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}}}}}},\"zh-CN\":{\"label\":\"简体中文\",\"lang\":\"zh-CN\",\"link\":\"/\",\"description\":\"思维垃圾\",\"title\":\"v123ve\",\"themeConfig\":{\"darkModeSwitchLabel\":\"主题\",\"docFooter\":{\"prev\":\"上一篇\",\"next\":\"下一篇\"},\"lastUpdatedText\":\"最后更新\",\"nav\":[{\"text\":\"主页\",\"link\":\"/\"},{\"text\":\"学习笔记\",\"items\":[{\"text\":\"23种设计模式(6)\",\"link\":\"/zh-CN/学习笔记/23种设计模式(6)\"},{\"text\":\"annatation注解\",\"link\":\"/zh-CN/学习笔记/annatation注解\"},{\"text\":\"Apache Shiro\",\"link\":\"/zh-CN/学习笔记/Apache Shiro\"},{\"text\":\"BinaryInsertSort.java\",\"link\":\"/zh-CN/学习笔记/BinaryInsertSort.java\"},{\"text\":\"IOC 控制反转（inversion of control）\",\"link\":\"/zh-CN/学习笔记/IOC 控制反转（inversion of control）\"},{\"text\":\"java-web工程\",\"link\":\"/zh-CN/学习笔记/java-web工程\"},{\"text\":\"java相关\",\"link\":\"/zh-CN/学习笔记/java相关\"},{\"text\":\"java高级特性\",\"link\":\"/zh-CN/学习笔记/java高级特性\"},{\"text\":\"jdbc\",\"link\":\"/zh-CN/学习笔记/jdbc\"},{\"text\":\"linux\",\"link\":\"/zh-CN/学习笔记/linux\"},{\"text\":\"mybatis\",\"link\":\"/zh-CN/学习笔记/mybatis\"},{\"text\":\"myxml\",\"link\":\"/zh-CN/学习笔记/myxml\"},{\"text\":\"nginx简介\",\"link\":\"/zh-CN/学习笔记/nginx简介\"},{\"text\":\"Redis\",\"link\":\"/zh-CN/学习笔记/Redis\"},{\"text\":\"shell编程\",\"link\":\"/zh-CN/学习笔记/shell编程\"},{\"text\":\"socket tcp udp\",\"link\":\"/zh-CN/学习笔记/socket tcp udp\"},{\"text\":\"Spring Boot\",\"link\":\"/zh-CN/学习笔记/Spring Boot\"},{\"text\":\"spring mvc 多线程并发\",\"link\":\"/zh-CN/学习笔记/spring mvc 多线程并发\"},{\"text\":\"SpringBoot\",\"link\":\"/zh-CN/学习笔记/SpringBoot\"},{\"text\":\"springmvc的配置：\",\"link\":\"/zh-CN/学习笔记/springmvc的配置：\"},{\"text\":\"spring定时任务\",\"link\":\"/zh-CN/学习笔记/spring定时任务\"},{\"text\":\"spring简介\",\"link\":\"/zh-CN/学习笔记/spring简介\"},{\"text\":\"Swagger\",\"link\":\"/zh-CN/学习笔记/Swagger\"},{\"text\":\"web.xml\",\"link\":\"/zh-CN/学习笔记/web.xml\"},{\"text\":\"Zookeeper\",\"link\":\"/zh-CN/学习笔记/Zookeeper\"},{\"text\":\"二期\",\"link\":\"/zh-CN/学习笔记/二期\"},{\"text\":\"代理模式\",\"link\":\"/zh-CN/学习笔记/代理模式\"},{\"text\":\"使用Heritrix 爬取网络资源\",\"link\":\"/zh-CN/学习笔记/使用Heritrix 爬取网络资源\"},{\"text\":\"分布式微服务架构原理\",\"link\":\"/zh-CN/学习笔记/分布式微服务架构原理\"},{\"text\":\"分布式搜索框架ES\",\"link\":\"/zh-CN/学习笔记/分布式搜索框架ES\"},{\"text\":\"分布式消息队列kafka\",\"link\":\"/zh-CN/学习笔记/分布式消息队列kafka\"},{\"text\":\"四大金刚\",\"link\":\"/zh-CN/学习笔记/四大金刚\"},{\"text\":\"在JS中获取文件点之后的后缀字符\",\"link\":\"/zh-CN/学习笔记/在JS中获取文件点之后的后缀字符\"},{\"text\":\"大数据\",\"link\":\"/zh-CN/学习笔记/大数据\"},{\"text\":\"排序\",\"link\":\"/zh-CN/学习笔记/排序\"},{\"text\":\"获取行政区范围\",\"link\":\"/zh-CN/学习笔记/获取行政区范围\"},{\"text\":\"菱形\",\"link\":\"/zh-CN/学习笔记/菱形\"},{\"text\":\"进程和线程的区别：\",\"link\":\"/zh-CN/学习笔记/进程和线程的区别：\"},{\"text\":\"零XML配置ss\",\"link\":\"/zh-CN/学习笔记/零XML配置ss\"},{\"text\":\"零配置ssm框架整合\",\"link\":\"/zh-CN/学习笔记/零配置ssm框架整合\"},{\"text\":\"面试经验\",\"link\":\"/zh-CN/学习笔记/面试经验\"}]},{\"text\":\"工作笔记\",\"items\":[{\"text\":\"ad-grid按无、符号、数字、字母、中文排序\",\"link\":\"/zh-CN/工作笔记/ad-grid按无、符号、数字、字母、中文排序\"},{\"text\":\"CodeMirror\",\"link\":\"/zh-CN/工作笔记/CodeMirror\"},{\"text\":\"content图标库\",\"link\":\"/zh-CN/工作笔记/content图标库\"},{\"text\":\"CSS常用操作\",\"link\":\"/zh-CN/工作笔记/CSS常用操作\"},{\"text\":\"CSS酷炫实现\",\"link\":\"/zh-CN/工作笔记/CSS酷炫实现\"},{\"text\":\"Docker\",\"link\":\"/zh-CN/工作笔记/Docker\"},{\"text\":\"dumi\",\"link\":\"/zh-CN/工作笔记/dumi\"},{\"text\":\"easy-ui常用操作\",\"link\":\"/zh-CN/工作笔记/easy-ui常用操作\"},{\"text\":\"ES6多继承\",\"link\":\"/zh-CN/工作笔记/ES6多继承\"},{\"text\":\"idea设置教程\",\"link\":\"/zh-CN/工作笔记/idea设置教程\"},{\"text\":\"iframe跨域\",\"link\":\"/zh-CN/工作笔记/iframe跨域\"},{\"text\":\"JavaUtils\",\"link\":\"/zh-CN/工作笔记/JavaUtils\"},{\"text\":\"java常用操作\",\"link\":\"/zh-CN/工作笔记/java常用操作\"},{\"text\":\"js常用操作\",\"link\":\"/zh-CN/工作笔记/js常用操作\"},{\"text\":\"js生成树\",\"link\":\"/zh-CN/工作笔记/js生成树\"},{\"text\":\"less\",\"link\":\"/zh-CN/工作笔记/less\"},{\"text\":\"listary集成everything\",\"link\":\"/zh-CN/工作笔记/listary集成everything\"},{\"text\":\"lodash\",\"link\":\"/zh-CN/工作笔记/lodash\"},{\"text\":\"mock示例\",\"link\":\"/zh-CN/工作笔记/mock示例\"},{\"text\":\"nginx不缓存设置\",\"link\":\"/zh-CN/工作笔记/nginx不缓存设置\"},{\"text\":\"nginx正则取反\",\"link\":\"/zh-CN/工作笔记/nginx正则取反\"},{\"text\":\"NodeJs和WebPack\",\"link\":\"/zh-CN/工作笔记/NodeJs和WebPack\"},{\"text\":\"React常用操作\",\"link\":\"/zh-CN/工作笔记/React常用操作\"},{\"text\":\"React高级\",\"link\":\"/zh-CN/工作笔记/React高级\"},{\"text\":\"samba\",\"link\":\"/zh-CN/工作笔记/samba\"},{\"text\":\"Sql相关\",\"link\":\"/zh-CN/工作笔记/Sql相关\"},{\"text\":\"umi2_pnpm\",\"link\":\"/zh-CN/工作笔记/umi2_pnpm\"},{\"text\":\"VideoCommon\",\"link\":\"/zh-CN/工作笔记/VideoCommon\"},{\"text\":\"VSCode\",\"link\":\"/zh-CN/工作笔记/VSCode\"},{\"text\":\"Webpack代码混淆\",\"link\":\"/zh-CN/工作笔记/Webpack代码混淆\"},{\"text\":\"WebSocket\",\"link\":\"/zh-CN/工作笔记/WebSocket\"},{\"text\":\"windows常用操作\",\"link\":\"/zh-CN/工作笔记/windows常用操作\"},{\"text\":\"创建offer\",\"link\":\"/zh-CN/工作笔记/创建offer\"},{\"text\":\"前端开发环境部署\",\"link\":\"/zh-CN/工作笔记/前端开发环境部署\"},{\"text\":\"加密解密\",\"link\":\"/zh-CN/工作笔记/加密解密\"},{\"text\":\"叉号\",\"link\":\"/zh-CN/工作笔记/叉号\"},{\"text\":\"双击处理\",\"link\":\"/zh-CN/工作笔记/双击处理\"},{\"text\":\"向量叉乘\",\"link\":\"/zh-CN/工作笔记/向量叉乘\"},{\"text\":\"响应系统的作用与实现\",\"link\":\"/zh-CN/工作笔记/响应系统的作用与实现\"},{\"text\":\"奇偶岸边\",\"link\":\"/zh-CN/工作笔记/奇偶岸边\"},{\"text\":\"安装\",\"link\":\"/zh-CN/工作笔记/安装\"},{\"text\":\"排序和树\",\"link\":\"/zh-CN/工作笔记/排序和树\"},{\"text\":\"文件下载\",\"link\":\"/zh-CN/工作笔记/文件下载\"},{\"text\":\"渲染器和Diff算法\",\"link\":\"/zh-CN/工作笔记/渲染器和Diff算法\"},{\"text\":\"生成饼状图\",\"link\":\"/zh-CN/工作笔记/生成饼状图\"}]},{\"text\":\"记录笔记\",\"items\":[]}],\"outline\":{\"level\":[2,6],\"label\":\"目录\"},\"returnToTopLabel\":\"返回顶部\",\"sidebarMenuLabel\":\"菜单\",\"sidebar\":{\"/zh-CN/docs/学习笔记/\":[{\"text\":\"学习笔记\",\"collapsed\":true,\"items\":[{\"text\":\"23种设计模式(6)\",\"link\":\"/zh-CN/学习笔记/23种设计模式(6)\"},{\"text\":\"annatation注解\",\"link\":\"/zh-CN/学习笔记/annatation注解\"},{\"text\":\"Apache Shiro\",\"link\":\"/zh-CN/学习笔记/Apache Shiro\"},{\"text\":\"BinaryInsertSort.java\",\"link\":\"/zh-CN/学习笔记/BinaryInsertSort.java\"},{\"text\":\"IOC 控制反转（inversion of control）\",\"link\":\"/zh-CN/学习笔记/IOC 控制反转（inversion of control）\"},{\"text\":\"java-web工程\",\"link\":\"/zh-CN/学习笔记/java-web工程\"},{\"text\":\"java相关\",\"link\":\"/zh-CN/学习笔记/java相关\"},{\"text\":\"java高级特性\",\"link\":\"/zh-CN/学习笔记/java高级特性\"},{\"text\":\"jdbc\",\"link\":\"/zh-CN/学习笔记/jdbc\"},{\"text\":\"linux\",\"link\":\"/zh-CN/学习笔记/linux\"},{\"text\":\"mybatis\",\"link\":\"/zh-CN/学习笔记/mybatis\"},{\"text\":\"myxml\",\"link\":\"/zh-CN/学习笔记/myxml\"},{\"text\":\"nginx简介\",\"link\":\"/zh-CN/学习笔记/nginx简介\"},{\"text\":\"Redis\",\"link\":\"/zh-CN/学习笔记/Redis\"},{\"text\":\"shell编程\",\"link\":\"/zh-CN/学习笔记/shell编程\"},{\"text\":\"socket tcp udp\",\"link\":\"/zh-CN/学习笔记/socket tcp udp\"},{\"text\":\"Spring Boot\",\"link\":\"/zh-CN/学习笔记/Spring Boot\"},{\"text\":\"spring mvc 多线程并发\",\"link\":\"/zh-CN/学习笔记/spring mvc 多线程并发\"},{\"text\":\"SpringBoot\",\"link\":\"/zh-CN/学习笔记/SpringBoot\"},{\"text\":\"springmvc的配置：\",\"link\":\"/zh-CN/学习笔记/springmvc的配置：\"},{\"text\":\"spring定时任务\",\"link\":\"/zh-CN/学习笔记/spring定时任务\"},{\"text\":\"spring简介\",\"link\":\"/zh-CN/学习笔记/spring简介\"},{\"text\":\"Swagger\",\"link\":\"/zh-CN/学习笔记/Swagger\"},{\"text\":\"web.xml\",\"link\":\"/zh-CN/学习笔记/web.xml\"},{\"text\":\"Zookeeper\",\"link\":\"/zh-CN/学习笔记/Zookeeper\"},{\"text\":\"二期\",\"link\":\"/zh-CN/学习笔记/二期\"},{\"text\":\"代理模式\",\"link\":\"/zh-CN/学习笔记/代理模式\"},{\"text\":\"使用Heritrix 爬取网络资源\",\"link\":\"/zh-CN/学习笔记/使用Heritrix 爬取网络资源\"},{\"text\":\"分布式微服务架构原理\",\"link\":\"/zh-CN/学习笔记/分布式微服务架构原理\"},{\"text\":\"分布式搜索框架ES\",\"link\":\"/zh-CN/学习笔记/分布式搜索框架ES\"},{\"text\":\"分布式消息队列kafka\",\"link\":\"/zh-CN/学习笔记/分布式消息队列kafka\"},{\"text\":\"四大金刚\",\"link\":\"/zh-CN/学习笔记/四大金刚\"},{\"text\":\"在JS中获取文件点之后的后缀字符\",\"link\":\"/zh-CN/学习笔记/在JS中获取文件点之后的后缀字符\"},{\"text\":\"大数据\",\"link\":\"/zh-CN/学习笔记/大数据\"},{\"text\":\"排序\",\"link\":\"/zh-CN/学习笔记/排序\"},{\"text\":\"获取行政区范围\",\"link\":\"/zh-CN/学习笔记/获取行政区范围\"},{\"text\":\"菱形\",\"link\":\"/zh-CN/学习笔记/菱形\"},{\"text\":\"进程和线程的区别：\",\"link\":\"/zh-CN/学习笔记/进程和线程的区别：\"},{\"text\":\"零XML配置ss\",\"link\":\"/zh-CN/学习笔记/零XML配置ss\"},{\"text\":\"零配置ssm框架整合\",\"link\":\"/zh-CN/学习笔记/零配置ssm框架整合\"},{\"text\":\"面试经验\",\"link\":\"/zh-CN/学习笔记/面试经验\"}]}],\"/zh-CN/docs/工作笔记/\":[{\"text\":\"工作笔记\",\"collapsed\":true,\"items\":[{\"text\":\"ad-grid按无、符号、数字、字母、中文排序\",\"link\":\"/zh-CN/工作笔记/ad-grid按无、符号、数字、字母、中文排序\"},{\"text\":\"CodeMirror\",\"link\":\"/zh-CN/工作笔记/CodeMirror\"},{\"text\":\"content图标库\",\"link\":\"/zh-CN/工作笔记/content图标库\"},{\"text\":\"CSS常用操作\",\"link\":\"/zh-CN/工作笔记/CSS常用操作\"},{\"text\":\"CSS酷炫实现\",\"link\":\"/zh-CN/工作笔记/CSS酷炫实现\"},{\"text\":\"Docker\",\"link\":\"/zh-CN/工作笔记/Docker\"},{\"text\":\"dumi\",\"link\":\"/zh-CN/工作笔记/dumi\"},{\"text\":\"easy-ui常用操作\",\"link\":\"/zh-CN/工作笔记/easy-ui常用操作\"},{\"text\":\"ES6多继承\",\"link\":\"/zh-CN/工作笔记/ES6多继承\"},{\"text\":\"idea设置教程\",\"link\":\"/zh-CN/工作笔记/idea设置教程\"},{\"text\":\"iframe跨域\",\"link\":\"/zh-CN/工作笔记/iframe跨域\"},{\"text\":\"JavaUtils\",\"link\":\"/zh-CN/工作笔记/JavaUtils\"},{\"text\":\"java常用操作\",\"link\":\"/zh-CN/工作笔记/java常用操作\"},{\"text\":\"js常用操作\",\"link\":\"/zh-CN/工作笔记/js常用操作\"},{\"text\":\"js生成树\",\"link\":\"/zh-CN/工作笔记/js生成树\"},{\"text\":\"less\",\"link\":\"/zh-CN/工作笔记/less\"},{\"text\":\"listary集成everything\",\"link\":\"/zh-CN/工作笔记/listary集成everything\"},{\"text\":\"lodash\",\"link\":\"/zh-CN/工作笔记/lodash\"},{\"text\":\"mock示例\",\"link\":\"/zh-CN/工作笔记/mock示例\"},{\"text\":\"nginx不缓存设置\",\"link\":\"/zh-CN/工作笔记/nginx不缓存设置\"},{\"text\":\"nginx正则取反\",\"link\":\"/zh-CN/工作笔记/nginx正则取反\"},{\"text\":\"NodeJs和WebPack\",\"link\":\"/zh-CN/工作笔记/NodeJs和WebPack\"},{\"text\":\"React常用操作\",\"link\":\"/zh-CN/工作笔记/React常用操作\"},{\"text\":\"React高级\",\"link\":\"/zh-CN/工作笔记/React高级\"},{\"text\":\"samba\",\"link\":\"/zh-CN/工作笔记/samba\"},{\"text\":\"Sql相关\",\"link\":\"/zh-CN/工作笔记/Sql相关\"},{\"text\":\"umi2_pnpm\",\"link\":\"/zh-CN/工作笔记/umi2_pnpm\"},{\"text\":\"VideoCommon\",\"link\":\"/zh-CN/工作笔记/VideoCommon\"},{\"text\":\"VSCode\",\"link\":\"/zh-CN/工作笔记/VSCode\"},{\"text\":\"Webpack代码混淆\",\"link\":\"/zh-CN/工作笔记/Webpack代码混淆\"},{\"text\":\"WebSocket\",\"link\":\"/zh-CN/工作笔记/WebSocket\"},{\"text\":\"windows常用操作\",\"link\":\"/zh-CN/工作笔记/windows常用操作\"},{\"text\":\"创建offer\",\"link\":\"/zh-CN/工作笔记/创建offer\"},{\"text\":\"前端开发环境部署\",\"link\":\"/zh-CN/工作笔记/前端开发环境部署\"},{\"text\":\"加密解密\",\"link\":\"/zh-CN/工作笔记/加密解密\"},{\"text\":\"叉号\",\"link\":\"/zh-CN/工作笔记/叉号\"},{\"text\":\"双击处理\",\"link\":\"/zh-CN/工作笔记/双击处理\"},{\"text\":\"向量叉乘\",\"link\":\"/zh-CN/工作笔记/向量叉乘\"},{\"text\":\"响应系统的作用与实现\",\"link\":\"/zh-CN/工作笔记/响应系统的作用与实现\"},{\"text\":\"奇偶岸边\",\"link\":\"/zh-CN/工作笔记/奇偶岸边\"},{\"text\":\"安装\",\"link\":\"/zh-CN/工作笔记/安装\"},{\"text\":\"排序和树\",\"link\":\"/zh-CN/工作笔记/排序和树\"},{\"text\":\"文件下载\",\"link\":\"/zh-CN/工作笔记/文件下载\"},{\"text\":\"渲染器和Diff算法\",\"link\":\"/zh-CN/工作笔记/渲染器和Diff算法\"},{\"text\":\"生成饼状图\",\"link\":\"/zh-CN/工作笔记/生成饼状图\"}]}],\"/zh-CN/docs/记录笔记/\":[{\"text\":\"记录笔记\",\"collapsed\":true,\"items\":[]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/vuejs/vitepress\"}],\"search\":{\"provider\":\"local\",\"options\":{\"locales\":{\"zh-CN\":{\"translations\":{\"button\":{\"buttonText\":\"搜索\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"displayDetails\":\"显示详细列表\",\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询结果\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}}}}}},\"en-US\":{\"label\":\"English\",\"lang\":\"en-US\",\"link\":\"/\",\"description\":\"思维垃圾\",\"title\":\"v123ve\",\"themeConfig\":{\"darkModeSwitchLabel\":\"Theme\",\"docFooter\":{\"prev\":\"Previous page\",\"next\":\"Next page\"},\"lastUpdatedText\":\"Last updated\",\"nav\":[{\"text\":\"Home\",\"link\":\"/\"}],\"outline\":{\"level\":[2,6],\"label\":\"List\"},\"returnToTopLabel\":\"Return to the top\",\"sidebarMenuLabel\":\"Menu\",\"sidebar\":{\"/en-US/\":[]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/vuejs/vitepress\"}]}}},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>